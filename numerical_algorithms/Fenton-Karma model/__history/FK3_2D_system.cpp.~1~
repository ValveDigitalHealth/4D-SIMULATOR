#include <stdlib.h>
#include <math.h>
#include <fstream.h>
#include <vcl.h>
#include "FK3_2D_system.h"

#pragma hdrstop

//---------------------------------------------------------------------------
#pragma package(smart_init)

//---------------------------------------------------------------------------

FK3_2D_system_class::~FK3_2D_system_class()
{
	//
}
//---------------------------------------------------------------------------

FK3_2D_system_class::FK3_2D_system_class()
{
	Min_Voltage = 0;
	Max_Voltage = 1;

	Min_Diff = 0;
	Max_Diff_X = 0.2;
	Max_Diff_Y = 0.2;

	dx = 0.6;
	dt = 0.001;  // normal
//	dt = 0.002;    // slow for animations

	Size_X = TWO_DIM_SYSTEM_X_SIZE;
	Size_Y = TWO_DIM_SYSTEM_Y_SIZE;

	Global_Time=0;

	// Load phase vector
/*
	ifstream dfile;
	char s[3000];
	dfile.open( "FK3_phase.txt" );
	if(dfile==NULL) ShowMessage("Unable to open FK3_phase.txt file");
	else
	{
		dfile >> FK3_APD_Length;
		FK3_Activation_Variable_APD = new double[FK3_APD_Length];
		FK3_Recovery_Variable_APD = new double[FK3_APD_Length];

		for(long i=0;i<FK3_APD_Length;i++)
		{
			dfile >> s; FK3_Activation_Variable_APD[i] = atof(s);
			dfile >> s; FK3_Recovery_Variable_APD[i] = atof(s);
		}
	}
*/
	Min_Custom_Value = 0;
	Max_Custom_Value = 1;

	initConsts();
	allocate_tables();
	clear_system();
}

//---------------------------------------------------------------------------

void FK3_2D_system_class::initConsts()
{
CONSTANTS[0] = 1;
CONSTANTS[1] = -85;
CONSTANTS[2] = 15;
CONSTANTS[3] = 0.13;
CONSTANTS[4] = 0.04;
CONSTANTS[5] = 4;
CONSTANTS[6] = 1250;
CONSTANTS[7] = 19.6;
CONSTANTS[8] = 3.33;
CONSTANTS[9] = 12.5;
CONSTANTS[10] = 33.33;
CONSTANTS[11] = 29;
CONSTANTS[12] = 0.85;
CONSTANTS[13] = 10;
CONSTANTS[14] = 41;
CONSTANTS[15] = 870;
CONSTANTS[16] = 10;
CONSTANTS[17] = 50000;
CONSTANTS[18] = -0.2;
CONSTANTS[19] = 1000;
CONSTANTS[20] = 1;
CONSTANTS[21] = CONSTANTS[0]/CONSTANTS[5];

}

//---------------------------------------------------------------------------

int FK3_2D_system_class::allocate_tables()
{
	vector_of_doubles D;
	D.DVector.clear();
	Middle_Row_Voltage_History.clear();
	Middle_Row_Voltage_History.assign(Size_X,D);

	for( int i=0; i<Size_X; i++)
	for( int j=0; j<Size_Y; j++)
	{
		DX[i][j] = Max_Diff_X;
		DY[i][j] = Max_Diff_Y;
		// G_fi_max[i][j] = g_fi_max;
		VOLTAGE_HISTORY[i][j].DVector.clear();
		CUSTOM_VALUE[i][j]=0.5;
	}

	return 1;
}

//---------------------------------------------------------------------------

int FK3_2D_system_class::free_tables()
{
	//
}

//---------------------------------------------------------------------------

void FK3_2D_system_class::clear_system()
{
	for(int i=0;i<8;i++)
	ALGEBRAIC[i] = 0;

	for(int i=0;i<3;i++)
	RATES[i] = 0;

	// Clear grid
	for( int i=0; i<Size_X; i++)
	for( int j=0; j<Size_Y; j++)
	{
		STATES_1[i][j][0] = 0;
		STATES_2[i][j][0] = 0;

		STATES_1[i][j][1] = 1;
		STATES_2[i][j][1] = 1;

		STATES_1[i][j][2] = 1;
		STATES_2[i][j][2] = 1;

		CUSTOM_VALUE[i][j] = 0;
	}

	// signals history
	for(long i=0;i<Middle_Row_Voltage_History.size();i++)
	Middle_Row_Voltage_History[i].DVector.clear();

}

//---------------------------------------------------------------------------

void FK3_2D_system_class::set_mi_distribution(double mi1_left,double mi2_left,
							 double mi1_right,double mi2_right,
							 double Ratio)
{
/*
	if( Ratio >= 0 & Ratio <= 1 )
	{

	for( int i=0; i<Ratio*Size_X; i++)
	for( int j=0; j<Size_Y; j++)
	{
		MI1[i][j] = mi1_left;
		MI2[i][j] = mi2_left;
	}

	for( int i=Ratio*Size_X; i<Size_X; i++)
	for( int j=0; j<Size_Y; j++)
	{
		MI1[i][j] = mi1_right;
		MI2[i][j] = mi2_right;
	}
	}
*/
}

//---------------------------------------------------------------------------
void FK3_2D_system_class::set_mi_breakup_rings(double mi1_min,double mi1_max,
							 double Radius, long Number,bool Middle)
{
/*
	// set all to normal value
	for( int i=0; i<Size_X; i++)
	for( int j=0; j<Size_Y; j++)
	{
		MI1[i][j] = mi1_max;
	}

	//------------------------------
	// discs  xxx
	//------------------------------
	for(int i=0;i<Number;i++)
	{

	int x = random( Size_X );
	int y = random( Size_Y );

	if( Middle )
	{
		x = 0.5*Size_X;
		y = 0.5*Size_Y;
	}

	for( int i1=x-Radius; i1<x+Radius; i1++)
	for( int j1=y-Radius; j1<y+Radius; j1++)
	if( sqrt(pow(i1-x,2)+pow(j1-y,2)) < Radius )
	if( i1 >= 0 && i1 < Size_X )
	if( j1 >= 0 && j1 < Size_Y )
	{
		MI1[i1][j1] = mi1_min;
	}

	}
*/
}

//---------------------------------------------------------------------------
void FK3_2D_system_class::set_mi_breakup_landscape(double R, double p, double I,
		double min, double max, int Target_Variable)
{
/*

	double r;

	if( Target_Variable == 0 )
		set_initial_coupling();
	else
	for( int i=0; i<Size_X; i++)
	for( int j=0; j<Size_Y; j++)
	{
		if( Target_Variable == 1 ) 	G_fi_max[i][j] = max;
		// if( Target_Variable == 2 ) 	MI2[i][j] = max;
	}

	for( int i=0; i<Size_X; i++)
	for( int j=0; j<Size_Y; j++)
	{

	if( random( 100000 ) / 100000.0 < p )
	for( int i1=i;i1<= i+2*R;i1++)
	for( int j1=j;j1<= j+2*R;j1++)
	if( i1 < Size_X && j1 < Size_Y )
	{
		r = sqrt( std::pow(i1-R-i,2) + std::pow(j1-R-j,2) );
		if( r <= R )
		{
			if( Target_Variable == 0 ) 	{ DX[i1][j1] -= I*(R-r)/R; DY[i1][j1] -= I*(R-r)/R; }
			if( Target_Variable == 1 ) 	G_fi_max[i1][j1] -= I*(R-r)/R;
			//if( Target_Variable == 2 ) 	MI2[i1][j1] -= I*(R-r)/R;
		}

			if( Target_Variable == 0 ) 	{ if( DX[i1][j1] < min ) DX[i1][j1] = min; if( DY[i1][j1] < min ) DY[i1][j1] = min; }
			if( Target_Variable == 1 ) 	if( G_fi_max[i1][j1] < min ) G_fi_max[i1][j1] = min;
			// if( Target_Variable == 2 ) 	if( MI2[i1][j1] < min ) MI2[i1][j1] = min;
	}

	}
*/

}

//---------------------------------------------------------------------------

void FK3_2D_system_class::refresh_VW_matrices() // to avoid drop in efficiency
{
	// Clear grid
	for( int i=0; i<Size_X; i++)
	for( int j=0; j<Size_Y; j++)
	if( DX[i][j]==0 && DY[i][j]==0 )
	{
		STATES_1[i][j][0] = 0;
		STATES_2[i][j][0] = 0;

		STATES_1[i][j][1] = 1;
		STATES_2[i][j][1] = 1;

		STATES_1[i][j][2] = 1;
		STATES_2[i][j][2] = 1;
	}
}

//---------------------------------------------------------------------------

void FK3_2D_system_class::record_potentials()
{
	int j = Size_Y/2;
	for( int i=0; i<Size_X; i++)
		Middle_Row_Voltage_History[i].DVector.push_back(STATES_1[i][j][0]);

	for( int i=0; i<Size_X; i++)
	for( int j=0; j<Size_Y; j++)
		VOLTAGE_HISTORY[i][j].DVector.push_back(STATES_1[i][j][0]);
}

//---------------------------------------------------------------------------

void FK3_2D_system_class::compute_N_steps(int N)
{
	for(int n=0;n<N;n++)
	{
		calculate_V1_from_V2();
		calculate_V2_from_V1();
		Global_Time = Global_Time + dt;

		add_assymetric_modulation();
		add_current_modulation_1();

	}
}

//--------------------------------------------------------------

void FK3_2D_system_class::calculate_V2_from_V1()
{
//fff21
	  double diff_term,s2=dx*dx;

	  // matrix V without boundaries
	  for(int i = 1; i < Size_X - 1; i++ )
	  for(int j = 1; j < Size_Y - 1; j++ )
	  {
		diff_term = ( DX[i][j]*(STATES_1[i-1][j][0] + STATES_1[i+1][j][0] - 2*STATES_1[i][j][0]) +
					  DY[i][j]*(STATES_1[i][j+1][0] + STATES_1[i][j-1][0] - 2*STATES_1[i][j][0]) ) / s2;

		// Forward Euler

		if( diff_term != 0 )
		int df=34;

		//variables
		ALGEBRAIC[1] = (STATES_1[i][j][0]<CONSTANTS[3] ? 0.0 : 1.0);
		ALGEBRAIC[3] = (STATES_1[i][j][0]<CONSTANTS[4] ? 0.0 : 1.0);
		ALGEBRAIC[5] =  ALGEBRAIC[3]*CONSTANTS[6]+ (1.0 - ALGEBRAIC[3])*CONSTANTS[7];
		ALGEBRAIC[2] = ( - STATES_1[i][j][1]*ALGEBRAIC[1]*(1.0 - STATES_1[i][j][0])*(STATES_1[i][j][0] - CONSTANTS[3]))/CONSTANTS[21];
		ALGEBRAIC[4] = ( STATES_1[i][j][0]*(1.0 - ALGEBRAIC[1]))/CONSTANTS[9]+ALGEBRAIC[1]/CONSTANTS[10];
		ALGEBRAIC[6] = ( - STATES_1[i][j][2]*(1.0+ fast_tanh( CONSTANTS[13]*(STATES_1[i][j][0] - CONSTANTS[12]))))/( 2.0*CONSTANTS[11]);
		ALGEBRAIC[7] = 0; // (VOI>=CONSTANTS[16]&&VOI<=CONSTANTS[17]&& (VOI - CONSTANTS[16]) -  floor((VOI - CONSTANTS[16])/CONSTANTS[19])*CONSTANTS[19] <=CONSTANTS[20] ? CONSTANTS[18] : 0.0);
		ALGEBRAIC[0] = CONSTANTS[1]+ STATES_1[i][j][0]*(CONSTANTS[2] - CONSTANTS[1]);

		// rates
		ALGEBRAIC[1] = (STATES_1[i][j][0]<CONSTANTS[3] ? 0.0 : 1.0);
		RATES[2] = ( (1.0 - ALGEBRAIC[1])*(1.0 - STATES_1[i][j][2]))/CONSTANTS[14] - ( ALGEBRAIC[1]*STATES_1[i][j][2])/CONSTANTS[15];
		ALGEBRAIC[3] = (STATES_1[i][j][0]<CONSTANTS[4] ? 0.0 : 1.0);
		ALGEBRAIC[5] =  ALGEBRAIC[3]*CONSTANTS[6]+ (1.0 - ALGEBRAIC[3])*CONSTANTS[7];
		RATES[1] = ( (1.0 - ALGEBRAIC[1])*(1.0 - STATES_1[i][j][1]))/ALGEBRAIC[5] - ( ALGEBRAIC[1]*STATES_1[i][j][1])/CONSTANTS[8];
		ALGEBRAIC[2] = ( - STATES_1[i][j][1]*ALGEBRAIC[1]*(1.0 - STATES_1[i][j][0])*(STATES_1[i][j][0] - CONSTANTS[3]))/CONSTANTS[21];
		ALGEBRAIC[4] = ( STATES_1[i][j][0]*(1.0 - ALGEBRAIC[1]))/CONSTANTS[9]+ALGEBRAIC[1]/CONSTANTS[10];
		ALGEBRAIC[6] = ( - STATES_1[i][j][2]*(1.0+ fast_tanh( CONSTANTS[13]*(STATES_1[i][j][0] - CONSTANTS[12]))))/( 2.0*CONSTANTS[11]);
		ALGEBRAIC[7] = 0; // (VOI>=CONSTANTS[16]&&VOI<=CONSTANTS[17]&&(VOI - CONSTANTS[16]) -  floor((VOI - CONSTANTS[16])/CONSTANTS[19])*CONSTANTS[19]<=CONSTANTS[20] ? CONSTANTS[18] : 0.0); // stim
		RATES[0] = - (ALGEBRAIC[2]+ALGEBRAIC[4]+ALGEBRAIC[6]+ALGEBRAIC[7]);

		// states update
		STATES_2[i][j][0] = STATES_1[i][j][0] + (RATES[0]+ diff_term)*dt;
		STATES_2[i][j][1] = STATES_1[i][j][1] + RATES[1]*dt;
		STATES_2[i][j][2] = STATES_1[i][j][2] + RATES[2]*dt;

	  }

	//---------------------------------------------------------------------
	if( Boundary_Conditions == 0 ) // zero flux
	//---------------------------------------------------------------------
	{
	  // "X" side
	  for(int i = 1; i < Size_X - 1; i++ )
	  {
			STATES_2[i][0][0] = STATES_2[i][1][0];
			STATES_2[i][Size_Y-1][0] = STATES_2[i][Size_Y-2][0];

			STATES_2[i][0][1] = STATES_2[i][1][1];
			STATES_2[i][Size_Y-1][1] = STATES_2[i][Size_Y-2][1];

			STATES_2[i][0][2] = STATES_2[i][1][2];
			STATES_2[i][Size_Y-1][2] = STATES_2[i][Size_Y-2][2];
	  }

	  // "Y" side
	  for(int j = 1; j < Size_Y - 1; j++ )
	  {
			STATES_2[0][j][0] = STATES_2[1][j][0];
			STATES_2[Size_X-1][j][0] = STATES_2[Size_Y-2][j][0];

			STATES_2[0][j][1] = STATES_2[1][j][1];
			STATES_2[Size_X-1][j][1] = STATES_2[Size_Y-2][j][1];

			STATES_2[0][j][2] = STATES_2[1][j][2];
			STATES_2[Size_X-1][j][2] = STATES_2[Size_Y-2][j][2];
	  }
	}
/*
	//---------------------------------------------------------------------
	if( Boundary_Conditions == 1 ) // periodic conditions
	//---------------------------------------------------------------------
	{
	  // "X" 0 side
	  i = 0;
	  for( j = 1; j < Size_Y - 1; j++ )
	  {
		diff_term = ( DX[i][j]*(V1[Size_X-1][j] + V1[1][j] -   2*STATES_1[i][j][0]) +
					  DY[i][j]*(V1[i][j+1]      + V1[i][j-1] - 2*STATES_1[i][j][0]) )/s2;

		// Forward Euler
		STATES_2[i][j][0] = STATES_1[i][j][0] + dt*
			( -k_par*STATES_1[i][j][0]*(STATES_1[i][j][0]-a)*(STATES_1[i][j][0]-1)-STATES_1[i][j][0]*W1[i][j]+ diff_term);

		W2[i][j] = W1[i][j] + dt*
		(eps+(MI1[i][j]*W1[i][j])/(MI2[i][j]+STATES_1[i][j][0]))*
			 (-W1[i][j]-k_par*STATES_1[i][j][0]*(STATES_1[i][j][0]-b-1));
	  }

	  // "X" Size_X-1 side
	  i = Size_X-1;
	  for( j = 1; j < Size_Y - 1; j++ )
	  {
		diff_term = ( DX[i][j]*(V1[Size_X-2][j] + V1[0][j] -  2*STATES_1[i][j][0]) +
					  DY[i][j]*(V1[i][j+1]      + V1[i][j-1]- 2*STATES_1[i][j][0]) )/s2;

		// Forward Euler
		STATES_2[i][j][0] = STATES_1[i][j][0] + dt*
			( -k_par*STATES_1[i][j][0]*(STATES_1[i][j][0]-a)*(STATES_1[i][j][0]-1)-STATES_1[i][j][0]*W1[i][j]+ diff_term);

		W2[i][j] = W1[i][j] + dt*
		(eps+(MI1[i][j]*W1[i][j])/(MI2[i][j]+STATES_1[i][j][0]))*
			 (-W1[i][j]-k_par*STATES_1[i][j][0]*(STATES_1[i][j][0]-b-1));
	  }

	  // "Y" 0 side
	  j = 0;
	  for( i = 1; i < Size_X - 1; i++ )
	  {
		diff_term = ( DX[i][j]*(V1[i-1][j]       + V1[i+1][j] -  2*STATES_1[i][j][0]) +
					  DY[i][j]*(V1[i][Size_Y-1]  + V1[i][1]   - 2*STATES_1[i][j][0]) )/s2;

		// Forward Euler
		STATES_2[i][j][0] = STATES_1[i][j][0] + dt*
			( -k_par*STATES_1[i][j][0]*(STATES_1[i][j][0]-a)*(STATES_1[i][j][0]-1)-STATES_1[i][j][0]*W1[i][j]+ diff_term);

		W2[i][j] = W1[i][j] + dt*
		(eps+(MI1[i][j]*W1[i][j])/(MI2[i][j]+STATES_1[i][j][0]))*
			 (-W1[i][j]-k_par*STATES_1[i][j][0]*(STATES_1[i][j][0]-b-1));
	  }

	  // "Y" Size_Y-1 side
      j = Size_Y-1;
	  for( i = 1; i < Size_X - 1; i++ )
      {
        diff_term = ( DX[i][j]*(V1[i-1][j]       + V1[i+1][j] -  2*STATES_1[i][j][0]) +
					  DY[i][j]*(V1[i][Size_Y-2]  + V1[i][0]   - 2*STATES_1[i][j][0]) )/s2;

		// Forward Euler
		STATES_2[i][j][0] = STATES_1[i][j][0] + dt*
			( -k_par*STATES_1[i][j][0]*(STATES_1[i][j][0]-a)*(STATES_1[i][j][0]-1)-STATES_1[i][j][0]*W1[i][j]+ diff_term);

        W2[i][j] = W1[i][j] + dt*
        (eps+(MI1[i][j]*W1[i][j])/(MI2[i][j]+STATES_1[i][j][0]))*
			 (-W1[i][j]-k_par*STATES_1[i][j][0]*(STATES_1[i][j][0]-b-1));
	  }

	}

*/

}

//------------------------------------------------------------------------------

void FK3_2D_system_class::calculate_V1_from_V2()
{
//fff12
	  int i,j,k,l;
	  double diff_term,s2=dx*dx;

	  // matrix V without boundaries
	  for( i = 1; i < Size_X - 1; i++ )
	  for( j = 1; j < Size_Y - 1; j++ )
	  {

		diff_term = ( DX[i][j]*(STATES_2[i-1][j][0] + STATES_2[i+1][j][0] - 2*STATES_2[i][j][0]) +
					  DY[i][j]*(STATES_2[i][j+1][0] + STATES_2[i][j-1][0] - 2*STATES_2[i][j][0]) ) / s2;

		// Forward Euler

		//variables
		ALGEBRAIC[1] = (STATES_2[i][j][0]<CONSTANTS[3] ? 0.0 : 1.0);
		ALGEBRAIC[3] = (STATES_2[i][j][0]<CONSTANTS[4] ? 0.0 : 1.0);
		ALGEBRAIC[5] =  ALGEBRAIC[3]*CONSTANTS[6]+ (1.0 - ALGEBRAIC[3])*CONSTANTS[7];
		ALGEBRAIC[2] = ( - STATES_2[i][j][1]*ALGEBRAIC[1]*(1.0 - STATES_2[i][j][0])*(STATES_2[i][j][0] - CONSTANTS[3]))/CONSTANTS[21];
		ALGEBRAIC[4] = ( STATES_2[i][j][0]*(1.0 - ALGEBRAIC[1]))/CONSTANTS[9]+ALGEBRAIC[1]/CONSTANTS[10];
		ALGEBRAIC[6] = ( - STATES_2[i][j][2]*(1.0+ fast_tanh( CONSTANTS[13]*(STATES_2[i][j][0] - CONSTANTS[12]))))/( 2.0*CONSTANTS[11]);
		ALGEBRAIC[7] = 0; // (VOI>=CONSTANTS[16]&&VOI<=CONSTANTS[17]&& (VOI - CONSTANTS[16]) -  floor((VOI - CONSTANTS[16])/CONSTANTS[19])*CONSTANTS[19] <=CONSTANTS[20] ? CONSTANTS[18] : 0.0);
		ALGEBRAIC[0] = CONSTANTS[1]+ STATES_2[i][j][0]*(CONSTANTS[2] - CONSTANTS[1]);

		// rates
		ALGEBRAIC[1] = (STATES_2[i][j][0]<CONSTANTS[3] ? 0.0 : 1.0);
		RATES[2] = ( (1.0 - ALGEBRAIC[1])*(1.0 - STATES_2[i][j][2]))/CONSTANTS[14] - ( ALGEBRAIC[1]*STATES_2[i][j][2])/CONSTANTS[15];
		ALGEBRAIC[3] = (STATES_2[i][j][0]<CONSTANTS[4] ? 0.0 : 1.0);
		ALGEBRAIC[5] =  ALGEBRAIC[3]*CONSTANTS[6]+ (1.0 - ALGEBRAIC[3])*CONSTANTS[7];
		RATES[1] = ( (1.0 - ALGEBRAIC[1])*(1.0 - STATES_2[i][j][1]))/ALGEBRAIC[5] - ( ALGEBRAIC[1]*STATES_2[i][j][1])/CONSTANTS[8];
		ALGEBRAIC[2] = ( - STATES_2[i][j][1]*ALGEBRAIC[1]*(1.0 - STATES_2[i][j][0])*(STATES_2[i][j][0] - CONSTANTS[3]))/CONSTANTS[21];
		ALGEBRAIC[4] = ( STATES_2[i][j][0]*(1.0 - ALGEBRAIC[1]))/CONSTANTS[9]+ALGEBRAIC[1]/CONSTANTS[10];
		ALGEBRAIC[6] = ( - STATES_2[i][j][2]*(1.0+ fast_tanh( CONSTANTS[13]*(STATES_2[i][j][0] - CONSTANTS[12]))))/( 2.0*CONSTANTS[11]);
		ALGEBRAIC[7] = 0; // (VOI>=CONSTANTS[16]&&VOI<=CONSTANTS[17]&&(VOI - CONSTANTS[16]) -  floor((VOI - CONSTANTS[16])/CONSTANTS[19])*CONSTANTS[19]<=CONSTANTS[20] ? CONSTANTS[18] : 0.0); // stim
		RATES[0] = - (ALGEBRAIC[2]+ALGEBRAIC[4]+ALGEBRAIC[6]+ALGEBRAIC[7]);

		// states update
		STATES_1[i][j][0] = STATES_2[i][j][0] + (RATES[0]+ diff_term)*dt;
		STATES_1[i][j][1] = STATES_2[i][j][1] + RATES[1]*dt;
		STATES_1[i][j][2] = STATES_2[i][j][2] + RATES[2]*dt;
	  }

	//---------------------------------------------------------------------
	if( Boundary_Conditions == 0 ) // zero flux
	//---------------------------------------------------------------------
	{
	  // "X" side
	  for( i = 1; i < Size_X - 1; i++ )
	  {
			STATES_1[i][0][0] = STATES_1[i][1][0];
			STATES_1[i][Size_Y-1][0] = STATES_1[i][Size_Y-2][0];

			STATES_1[i][0][1] = STATES_1[i][1][1];
			STATES_1[i][Size_Y-1][1] = STATES_1[i][Size_Y-2][1];

			STATES_1[i][0][2] = STATES_1[i][1][2];
			STATES_1[i][Size_Y-1][2] = STATES_1[i][Size_Y-2][2];
	  }

	  // "Y" side
	  for( j = 1; j < Size_Y - 1; j++ )
	  {
			STATES_1[0][j][0] = STATES_1[1][j][0];
			STATES_1[Size_X-1][j][0] = STATES_1[Size_Y-2][j][0];

			STATES_1[0][j][1] = STATES_1[1][j][1];
			STATES_1[Size_X-1][j][1] = STATES_1[Size_Y-2][j][1];

			STATES_1[0][j][2] = STATES_1[1][j][2];
			STATES_1[Size_X-1][j][2] = STATES_1[Size_Y-2][j][2];
	  }
	}
/*
	//---------------------------------------------------------------------
	if( Boundary_Conditions == 1 ) // periodic conditions
	//---------------------------------------------------------------------
	{
	  // "X" 0 side
	  i = 0;
	  for( j = 1; j < Size_Y - 1; j++ )
	  {

		diff_term = ( DX[i][j]*(V2[Size_X-1][j] + V2[1][j] -   2*STATES_2[i][j][0]) +
					  DY[i][j]*(V2[i][j+1]      + V2[i][j-1] - 2*STATES_2[i][j][0]) )/s2;

		// Forward Euler
		STATES_1[i][j][0] = STATES_2[i][j][0] + dt*
			( -k_par*STATES_2[i][j][0]*(STATES_2[i][j][0]-a)*(STATES_2[i][j][0]-1)-STATES_2[i][j][0]*W2[i][j]+ diff_term);

		W1[i][j] = W2[i][j] + dt*
		(eps+(MI1[i][j]*W2[i][j])/(MI2[i][j]+STATES_2[i][j][0]))*
			 (-W2[i][j]-k_par*STATES_2[i][j][0]*(STATES_2[i][j][0]-b-1));
	  }

	  // "X" Size_X-1 side
	  i = Size_X-1;
      for( j = 1; j < Size_Y - 1; j++ )
      {

        diff_term = ( DX[i][j]*(V2[Size_X-2][j] + V2[0][j] -  2*STATES_2[i][j][0]) +
                      DY[i][j]*(V2[i][j+1]      + V2[i][j-1]- 2*STATES_2[i][j][0]) )/s2;

        // Forward Euler
        STATES_1[i][j][0] = STATES_2[i][j][0] + dt*
            ( -k_par*STATES_2[i][j][0]*(STATES_2[i][j][0]-a)*(STATES_2[i][j][0]-1)-STATES_2[i][j][0]*W2[i][j]+ diff_term);

        W1[i][j] = W2[i][j] + dt*
        (eps+(MI1[i][j]*W2[i][j])/(MI2[i][j]+STATES_2[i][j][0]))*
             (-W2[i][j]-k_par*STATES_2[i][j][0]*(STATES_2[i][j][0]-b-1));
      }

      // "Y" 0 side
      j = 0;
      for( i = 1; i < Size_X - 1; i++ )
      {
		diff_term = ( DX[i][j]*(V2[i-1][j]       + V2[i+1][j] -  2*STATES_2[i][j][0]) +
                      DY[i][j]*(V2[i][Size_Y-1]  + V2[i][1]   - 2*STATES_2[i][j][0]) )/s2;

        // Forward Euler
        STATES_1[i][j][0] = STATES_2[i][j][0] + dt*
            ( -k_par*STATES_2[i][j][0]*(STATES_2[i][j][0]-a)*(STATES_2[i][j][0]-1)-STATES_2[i][j][0]*W2[i][j]+ diff_term);

        W1[i][j] = W2[i][j] + dt*
        (eps+(MI1[i][j]*W2[i][j])/(MI2[i][j]+STATES_2[i][j][0]))*
             (-W2[i][j]-k_par*STATES_2[i][j][0]*(STATES_2[i][j][0]-b-1));
      }

      // "Y" Size_Y-1 side
      j = Size_Y-1;
      for( i = 1; i < Size_X - 1; i++ )
	  {
		diff_term = ( DX[i][j]*(V2[i-1][j]       + V2[i+1][j] -  2*STATES_2[i][j][0]) +
					  DY[i][j]*(V2[i][Size_Y-2]  + V2[i][0]   - 2*STATES_2[i][j][0]) )/s2;

		// Forward Euler
		STATES_1[i][j][0] = STATES_2[i][j][0] + dt*
			( -k_par*STATES_2[i][j][0]*(STATES_2[i][j][0]-a)*(STATES_2[i][j][0]-1)-STATES_2[i][j][0]*W2[i][j]+ diff_term);

		W1[i][j] = W2[i][j] + dt*
		(eps+(MI1[i][j]*W2[i][j])/(MI2[i][j]+STATES_2[i][j][0]))*
			 (-W2[i][j]-k_par*STATES_2[i][j][0]*(STATES_2[i][j][0]-b-1));
	  }

	}
*/
}

//------------------------------------------------------------------------------

void FK3_2D_system_class::create_spiral(int Slice_Plane) // 0-xy,
{
    double wn,r,fi,phase,x,y,d;
    double cx,cy;
    long n;

    // winding number
    wn = 245.0;

    clear_system();

    cx = Size_X/2;
    cy = Size_Y/2;

    if( Slice_Plane == 0 ) // spiral wave in XY plane
    for( int i=0;i<Size_X; i++ )
    for( int j=0;j<Size_Y; j++ )
    {
        // distance from center of the spiral in dx units
        r = std::sqrt( std::pow(i-cx,2) + std::pow(j-cy,2));

        x = i-cx;
        y = j-cy;

        if( i-cx != 0.0 )
		{
            d = atan(fabs(y/x));

            // 1st quarter
            if( x >= 0 && y >= 0 )
				fi = d;

            // 2nd quarter
            if( x <= 0 && y >= 0 )
                fi = M_PI - d;

            // 3rd quarter
            if( x <= 0 && y <= 0 )
                fi = M_PI + d;

            // 4th quarter
            if( x >= 0 && y <= 0 )
                fi = 2.0*M_PI - d;
        }
        else
        {
            if( j-0.5*Size_Y > 0.0 )
                 fi = M_PI_2;
            else
                 fi = 3.0*M_PI_2;
        }

        fi += 0.55;

		// find the greatest n such that r > k*fi + 2pi*k*n
        if(wn*fi!=0)
            n = floor( (r-wn*fi)/(2.0*M_PI*wn) );
        else
            n = 0;

        phase = fabs(r-wn*fi-2.0*wn*M_PI*n)/(2.0*wn*M_PI);
        int m = (int)((1.0-phase)*(FK3_APD_Length-2));

        STATES_1[i][j][0] = FK3_Activation_Variable_APD[m];
		STATES_2[i][j][0] = FK3_Activation_Variable_APD[m];
//		IFI1[i][j] = 1*FK3_Recovery_Variable_APD[m];
//		IFI2[i][j] = 1*FK3_Recovery_Variable_APD[m];

		/// ADD MORE
    }
}

//---------------------------------------------------------------------------

int FK3_2D_system_class::get_color_code(int Source,int X,int Y)
{
	int ptr;

	if( Source == 0 )
	ptr = 255*(STATES_1[X][Y][0]-Min_Voltage)/(Max_Voltage-Min_Voltage);

	if( Source == 0 && DX[X][Y] <= Min_Voltage && DY[X][Y] <= 0.1 )
	ptr = -1;

	if( Source == 1 )
	ptr = 255-255*(DX[X][Y]-Min_Diff)/(2*Max_Diff_X-Min_Diff);

	if( Source == 2 )
	ptr = 255-255*(DY[X][Y]-Min_Diff)/(2*Max_Diff_Y-Min_Diff);

	double max_mi=0.4,min_mi=0;

	if( Source == 3 )
	ptr = 255-255*(G_fi_max[X][Y]-min_mi)/(max_mi-min_mi);
	if( Source == 4 )
	ptr = 255-255*(G_fi_max[X][Y]-min_mi)/(max_mi-min_mi);

	if( Source == 5 )
	ptr = 255-255*(CUSTOM_VALUE[X][Y]-Min_Custom_Value)/(Max_Custom_Value-Min_Custom_Value);

	if( Source == 5 && DY[X][Y] <= 0.1 )
	ptr = -1;

	if (ptr > 255) ptr = 255;

	return ptr;
}

//---------------------------------------------------------------------------

void FK3_2D_system_class::stimulate_node(int X,int Y)
{
	if( X >= 0 && X < TWO_DIM_SYSTEM_X_SIZE )
	if( Y >= 0 && Y < TWO_DIM_SYSTEM_Y_SIZE )
	{
	STATES_1[X][Y][0]=1;
	STATES_2[X][Y][0]=1;
	}
}

//---------------------------------------------------------------------------

void FK3_2D_system_class::compute_ISIs(long Node_Position)
{
    ISIs_Node_Ptr_X = Node_Position;
    ISIs.clear();

    double Threshold = 0.5;
    double prev=0,curr=0;

    int df= Middle_Row_Voltage_History[Node_Position].DVector.size();

    if( Node_Position >= 0 && Node_Position < Middle_Row_Voltage_History.size() )
    for(long t=1;t<(signed)Middle_Row_Voltage_History[Node_Position].DVector.size()-1;t++)
    if( Middle_Row_Voltage_History[Node_Position].DVector[t-1] < Threshold )
    if( Middle_Row_Voltage_History[Node_Position].DVector[t+1] > Threshold )
    {
        curr = t;

        if( prev != 0 )
            ISIs.push_back(curr-prev);

        prev = curr;

        t+=5; // forward jump in time
	}
}

//---------------------------------------------------------------------------

int FK3_2D_system_class::save_object(ofstream* dfile)
{
	dfile[0] << " FK3_version_1 ";

    dfile[0] << Size_X << " ";
    dfile[0] << Size_Y << " ";

    for(long i=0;i<Size_X;i++)
    for(long j=0;j<Size_Y;j++)
	{
		dfile[0] << STATES_1[i][j][0] << " ";
		dfile[0] << STATES_2[i][j][0] << " ";
		dfile[0] << DX[i][j] << " ";
		dfile[0] << DY[i][j] << " ";
		dfile[0] << G_fi_max[i][j] << " ";

		dfile[0] << VOLTAGE_HISTORY[i][j].DVector.size() << " ";
		for(long t=0;t<VOLTAGE_HISTORY[i][j].DVector.size();t++)
		dfile[0] << VOLTAGE_HISTORY[i][j].DVector[t] << " ";
	}


    dfile[0] << Middle_Row_Voltage_History.size() << " ";
    dfile[0] << Middle_Row_Voltage_History[0].DVector.size() << " ";
    for(long i=0;i<Middle_Row_Voltage_History.size();i++)
    for(long j=0;j<Middle_Row_Voltage_History[i].DVector.size();j++)
    dfile[0] <<  Middle_Row_Voltage_History[i].DVector[j] << " ";

    dfile[0] << ISIs.size() << " ";
    for(long i=0;i<ISIs.size();i++)
    dfile[0] <<  ISIs[i] << " ";

    dfile[0] << ISIs_Node_Ptr_X << " ";
    dfile[0] << Min_Voltage << " ";
    dfile[0] << Max_Voltage << " ";
    dfile[0] << Boundary_Conditions << " ";

	dfile[0] << dx << " ";
	dfile[0] << dt << " ";

	dfile[0] << Global_Time << " ";

}

//---------------------------------------------------------------------------

int FK3_2D_system_class::load_object(ifstream* dfile)
{
	char string[2000];

	dfile[0] >> string;

	if( !strcmp(string,"FK3_version_1") )
	{

	dfile[0] >> Size_X;
	dfile[0] >> Size_Y;

	if( Size_X != TWO_DIM_SYSTEM_X_SIZE ||
		Size_Y != TWO_DIM_SYSTEM_Y_SIZE )
	{
		ShowMessage("Incorrect system dimensions");
		return -1;
	}

	long S;
	double v;

	for(long i=0;i<Size_X;i++)
	for(long j=0;j<Size_Y;j++)
	{
		dfile[0] >> STATES_1[i][j][0];
		dfile[0] >> STATES_2[i][j][0];
		dfile[0] >> DX[i][j];
		dfile[0] >> DY[i][j];
		dfile[0] >> G_fi_max[i][j];

		dfile[0] >> S;

		for(long t=0;t<S;t++)
		{
			dfile[0] >> v;
			VOLTAGE_HISTORY[i][j].DVector.push_back(v);
		}
	}

	long S1,S2;
	double tmp;
	dfile[0] >> S1;
	dfile[0] >> S2;

	vector_of_doubles D;
	D.DVector.clear();
	D.DVector.assign(S2,tmp);
	Middle_Row_Voltage_History.clear();
	Middle_Row_Voltage_History.assign(S1,D);
	for(long i=0;i<Middle_Row_Voltage_History.size();i++)
	for(long j=0;j<Middle_Row_Voltage_History[i].DVector.size();j++)
	dfile[0] >>  Middle_Row_Voltage_History[i].DVector[j];

    dfile[0] >> S1;
    ISIs.assign(S1,tmp);
    for(long i=0;i<ISIs.size();i++)
    dfile[0] >>  ISIs[i];

    dfile[0] >> ISIs_Node_Ptr_X;
    dfile[0] >> Min_Voltage;
    dfile[0] >> Max_Voltage;
    dfile[0] >> Boundary_Conditions;

    dfile[0] >> dx;
    dfile[0] >> dt;

    dfile[0] >> Global_Time;

    ///////////////

    return 1;

	} // version_1

}

//---------------------------------------------------------------------------

void FK3_2D_system_class::add_assymetric_modulation()
{
	if( Add_Assymetric_Modulation )
	{
	double Modulation;

	double t1 = floor(Global_Time/Asm_Length)*Asm_Length;
	double t2 = (floor(Global_Time/Asm_Length)+1)*Asm_Length;

	if( Global_Time < t1 + Asm_Ratio*Asm_Length)
	Modulation = Asm_Amplitude*(Global_Time-t1)/(Asm_Ratio*Asm_Length);
	else
	Modulation = Asm_Amplitude*(t2-Global_Time)/((1-Asm_Ratio)*Asm_Length);

	long XL = 0.5*Size_X - Central_Region_Relative_Size*Size_X/2;
	long XR = 0.5*Size_X + Central_Region_Relative_Size*Size_X/2;

	long YL = 0.5*Size_Y - Central_Region_Relative_Size*Size_Y/2;
	long YR = 0.5*Size_Y + Central_Region_Relative_Size*Size_Y/2;

	for(long i=XL;i<XR;i++)
	for(long j=YL;j<YR;j++)
	{
		if(STATES_1[i][j][0] + Modulation < Max_Voltage )
		STATES_1[i][j][0] += Modulation;
		if(STATES_2[i][j][0] + Modulation < Max_Voltage )
		STATES_2[i][j][0] += Modulation;
	}

	}
}

//---------------------------------------------------------------------------

void FK3_2D_system_class::add_current_modulation_1()
{
	if( Add_Current_Modulation_1 )
	{
	double Modulation = CM1_Amplitude*sin(2*M_PI/CM1_Length*Global_Time);
	if( Modulation > 0 )
	Modulation = 0;

	long XL = 0.5*Size_X - Central_Region_Relative_Size*Size_X/2;
	long XR = 0.5*Size_X + Central_Region_Relative_Size*Size_X/2;

	long YL = 0.5*Size_Y - Central_Region_Relative_Size*Size_Y/2;
	long YR = 0.5*Size_Y + Central_Region_Relative_Size*Size_Y/2;

	for(long i=XL;i<XR;i++)
	for(long j=YL;j<YR;j++)
	{
		if(STATES_1[i][j][0] + Modulation < Max_Voltage )
		STATES_1[i][j][0] += Modulation;
		if(STATES_2[i][j][0] + Modulation < Max_Voltage )
		STATES_2[i][j][0] += Modulation;
	}

	}
}

//---------------------------------------------------------------------------

void FK3_2D_system_class::set_initial_coupling()
{
	for( int i=0; i<Size_X; i++)
	for( int j=0; j<Size_Y; j++)
	{
		DX[i][j] = Max_Diff_X;
		DY[i][j] = Max_Diff_Y;
	}
}

//---------------------------------------------------------------------------

void FK3_2D_system_class::add_coupling(int Version,bool Add_Rings)
{
	//------------------------------
	// discs
	//------------------------------
	if( Version == 1 )
	{
	int Curr_No = 0;
	while( Curr_No < Diff_v1_Number )
	{

	Curr_No++;
	int x = random( Size_X );
	int y = random( Size_Y );

	for( int i1=x-Diff_v1_Radius; i1<x+Diff_v1_Radius; i1++)
	for( int j1=y-Diff_v1_Radius; j1<y+Diff_v1_Radius; j1++)
	if( sqrt(pow(i1-x,2)+pow(j1-y,2)) < Diff_v1_Radius )
	if( i1 >= 0 && i1 < Size_X )
	if( j1 >= 0 && j1 < Size_Y )
	{
		DX[i1][j1] = 0;
		DY[i1][j1] = 0;
	}

	if(Add_Rings)
	for( int i1=x-Diff_v1_Radius-Ring_v1_Width; i1<x+Diff_v1_Radius+Ring_v1_Width; i1++)
	for( int j1=y-Diff_v1_Radius-Ring_v1_Width; j1<y+Diff_v1_Radius+Ring_v1_Width; j1++)
	if( sqrt(pow(i1-x,2)+pow(j1-y,2)) > Diff_v1_Radius )
	if( sqrt(pow(i1-x,2)+pow(j1-y,2)) < Diff_v1_Radius+Ring_v1_Width )
	if( i1 >= 0 && i1 < Size_X )
	if( j1 >= 0 && j1 < Size_Y )
	{
		DX[i1][j1] = (1.+Ring_v1_PercD/100.)*Max_Diff_X;
		DY[i1][j1] = (1.+Ring_v1_PercD/100.)*Max_Diff_Y;
	}

	}


	} // discs

	//------------------------------
	// lines
	//------------------------------
	if( Version == 2 )
	{

    for(long k=0;k<Lines_No_v1;k++)
    for(long ypos=Size_X*(100-Line_Perc_Leng_v1)*0.01*0.5;
             ypos<Size_X-Size_X*(100-Line_Perc_Leng_v1)*0.01*0.5;
             ypos++)
    {
        int xpos = (k+1)*Size_Y/Lines_No_v1;

        if( xpos > 0 && xpos < Size_X )
        if( ypos > 0 && ypos < Size_Y )
        {
			DX[xpos][ypos] = Line_Perc_D/100.*Max_Diff_X;
			DY[xpos][ypos] = Line_Perc_D/100.*Max_Diff_Y;
		}
	}

	} // discs

	//------------------------------
	// central disk
	//------------------------------
	if( Version == 3 )
	{

	for( int i1=Size_X/2-Disk_Radius; i1<Size_X/2+Disk_Radius; i1++)
	for( int j1=Size_Y/2-Disk_Radius; j1<Size_Y/2+Disk_Radius; j1++)
	if( sqrt(pow(i1-Size_X/2,2)+pow(j1-Size_Y/2,2)) < Disk_Radius )
	if( i1 >= 0 && i1 < Size_X )
	if( j1 >= 0 && j1 < Size_Y )
	{
		DX[i1][j1] = 0;
		DY[i1][j1] = 0;
	}

	} //  central disk

}

//---------------------------------------------------------------------------

void FK3_2D_system_class::stimulate_system(double Cx, double Cy)
{
	int Radius=5;
	int Pos_X = Cx*Size_X;
	int Pos_Y = Cy*Size_Y;

	for(int x=Pos_X-Radius;x<=Pos_X+Radius;x++)
	for(int y=Pos_Y-Radius;y<=Pos_Y+Radius;y++)
	stimulate_node(x,y);
}

//---------------------------------------------------------------------------

void FK3_2D_system_class::ablate_system(double Cx, double Cy)
{
	int Radius=4;
	int Pos_X = Cx*Size_X;
	int Pos_Y = Cy*Size_Y;
	double r;

	for(int x=Pos_X-Radius;x<=Pos_X+Radius;x++)
	for(int y=Pos_Y-Radius;y<=Pos_Y+Radius;y++)
	if(x>=0 && y>=0 && x<Size_X && y<Size_Y)
	{
		r = sqrt( pow(x-Pos_X,2) + pow(y-Pos_Y,2) );
		if( r < Radius )
		{
			DX[x][y]=0;
			DY[x][y]=0;
		}
	}
}

//---------------------------------------------------------------------------

vector <double> FK3_2D_system_class::calculate_unipolar_voltage_from_surface(int Node_x,long Node_y, long Range)
{
	vector <double> unipolar_voltage;
	double voltage,v,x,y,r;

	for(long t=0;t<VOLTAGE_HISTORY[0][0].DVector.size();t++)
	{

	voltage=0;
	for(int i=Node_x-Range;i<(signed)(Node_x+Range);i++)
	for(int j=Node_y-Range;j<(signed)(Node_y+Range);j++)
	if( i > 0 && i < Size_X-1 )
	if( j > 0 && j < Size_Y-1 )
	{

	v = VOLTAGE_HISTORY[i][j].DVector[t];
	x =  i - Node_x;
	y =  j - Node_y;
	r = std::pow( std::pow(x,2)+std::pow(y,2),1.5);

	if( r >= 2 )
	voltage -=
	 (  (VOLTAGE_HISTORY[i+1][j].DVector[t]-
		 VOLTAGE_HISTORY[i-1][j].DVector[t] )*x
		+

		(VOLTAGE_HISTORY[i][j+1].DVector[t]-
		 VOLTAGE_HISTORY[i][j-1].DVector[t] )*y
	 ) / r;

	} // for all nodes

	unipolar_voltage.push_back(voltage);

	} // through time

	return unipolar_voltage;
}

//------------------------------------------------------------------------------

bool FK3_2D_system_class::activity_present_check()
{
	bool Activity_Present = false;
	double Threshold = 0.5;

	for( int i=1; i<Size_X-1; i++)
	for( int j=1; j<Size_Y-1; j++)
	if( STATES_1[i][j][0] > Threshold )
		Activity_Present = true;

	return Activity_Present;
}

//------------------------------------------------------------------------------

void FK3_2D_system_class::add_non_conducting_disk(int X,int Y,int Z,int R)
{
	double r;

	for(int x=X-R;x<=X+R;x++)
	for(int y=Y-R;y<=Y+R;y++)
	if(x>=0 && y>=0 && x<Size_X && y<Size_Y)
	{
		r = sqrt( pow(x-X,2) + pow(y-Y,2) );
		if( 1) // r <= R )
		{
				DX[x][y]=0;
				DY[x][y]=0;
		}
	}
}

//------------------------------------------------------------------------------

void FK3_2D_system_class::add_critical_region(Two_D_system_CR_region_class CR)
{
	for(int r=0;r<CR.X.size();r++)
		add_non_conducting_disk(CR.X[r],CR.Y[r],0,CR.R[r]);
}

//------------------------------------------------------------------------------

double FK3_2D_system_class::get_voltage(int X, int Y)
{
	return STATES_1[X][Y][0];
}

//------------------------------------------------------------------------------
double FK3_2D_system_class::get_current(int X, int Y)
{
	return 0; // STATES_1[X][Y][0];
}

//------------------------------------------------------------------------------

double FK3_2D_system_class::fast_tanh(double x)
{
	double x2 = x * x;
	double a = x * (135135.0f + x2 * (17325.0f + x2 * (378.0f + x2)));
	double b = 135135.0f + x2 * (62370.0f + x2 * (3150.0f + x2 * 28.0f));
	return a / b;
}

//------------------------------------------------------------------------------

void FK3_2D_system_class::compute_ISIs_XY(int X, int Y)
{
	ISIs.clear();
	Activations_Positions.clear();

	double Threshold = 0.5;
	double prev=0,curr=0;

	if( X >= 0 && X < Size_X )
	if( Y >= 0 && Y < Size_Y )
	for(long t=1;t<(signed)VOLTAGE_HISTORY[X][Y].DVector.size()-1;t++)
	if( VOLTAGE_HISTORY[X][Y].DVector[t-1] < Threshold )
	if( VOLTAGE_HISTORY[X][Y].DVector[t+1] > Threshold )
	{
		curr = t;

		Activations_Positions.push_back(curr);

		if( prev != 0 )
			ISIs.push_back(curr-prev);

		prev = curr;

		t+=5; // forward jump in time
	}
}

//---------------------------------------------------------------------------
void FK3_2D_system_class::compute_min_max_custom_value()
{
	Min_Custom_Value = 100000000;
	Max_Custom_Value = -100000000;

	for( int i=0; i<Size_X; i++)
	for( int j=0; j<Size_Y; j++)
	{
		if( CUSTOM_VALUE[i][j] < Min_Custom_Value ) Min_Custom_Value = CUSTOM_VALUE[i][j];
		if( CUSTOM_VALUE[i][j] > Max_Custom_Value ) Max_Custom_Value = CUSTOM_VALUE[i][j];
	}

}

//------------------------------------------------------------------------------

double FK3_2D_system_class::get_custom_value(double Cx, double Cy)
{
	int X = Cx*Size_X;
	int Y = Cy*Size_Y;

	if( X>=0 && X < Size_X && Y>=0 && Y < Size_Y )
	return CUSTOM_VALUE[X][Y];
	else
	return 0;

}

//-------------------------------------------------------------------

