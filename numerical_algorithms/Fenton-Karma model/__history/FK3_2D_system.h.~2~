//---------------------------------------------------------------------------
#include "Numerical_Algorithms.h"

#ifndef FK3_2D_systemH
#define FK3_2D_systemH

#include "Program_Constants.h"

#include "Two_D_system_CR_region_class.h"

//---------------------------------------------------------------------------
/*
https://models.physiomeproject.org/e/40/fenton_karma_1998_BR.cellml/@@cellml_codegen/C

http://www.scholarpedia.org/article/Models_of_cardiac_cell
http://thevirtualheart.org/FentonCherry/pdf/chaos98.pdf

*/


class FK3_2D_system_class
{
    public:

    FK3_2D_system_class();
    ~FK3_2D_system_class();

	int save_object(ofstream* dfile);
	int load_object(ifstream* dfile);


	// data structures
	int Size_X;
	int Size_Y;

/*
   There are a total of 8 entries in the algebraic variable array.
   There are a total of 3 entries in each of the rate and state variable arrays.
   There are a total of 22 entries in the constant variable array.
 */
/*
 * VOI is time in component environment (ms).
 * STATES[0] is u in component membrane (dimensionless).
 * CONSTANTS[0] is Cm in component membrane (uF_per_cm2).
 * ALGEBRAIC[0] is Vm in component membrane (mV).
 * CONSTANTS[1] is V_0 in component membrane (mV).
 * CONSTANTS[2] is V_fi in component membrane (mV).
 * ALGEBRAIC[2] is J_fi in component fast_inward_current (per_ms).
 * ALGEBRAIC[4] is J_so in component slow_outward_current (per_ms).
 * ALGEBRAIC[6] is J_si in component slow_inward_current (per_ms).
 * ALGEBRAIC[7] is Istim in component stimulus_protocol (per_ms).
 * ALGEBRAIC[1] is p in component p (dimensionless).
 * CONSTANTS[3] is u_c in component p (dimensionless).
 * ALGEBRAIC[3] is q in component q (dimensionless).
 * CONSTANTS[4] is u_v in component q (dimensionless).
 * CONSTANTS[21] is tau_d in component fast_inward_current (ms).
 * CONSTANTS[5] is g_fi_max in component fast_inward_current (mS_per_cm2).
 * STATES[1] is v in component fast_inward_current_v_gate (dimensionless).
 * ALGEBRAIC[5] is tau_v_minus in component fast_inward_current_v_gate (ms).
 * CONSTANTS[6] is tau_v1_minus in component fast_inward_current_v_gate (ms).
 * CONSTANTS[7] is tau_v2_minus in component fast_inward_current_v_gate (ms).
 * CONSTANTS[8] is tau_v_plus in component fast_inward_current_v_gate (ms).
 * CONSTANTS[9] is tau_0 in component slow_outward_current (ms).
 * CONSTANTS[10] is tau_r in component slow_outward_current (ms).
 * CONSTANTS[11] is tau_si in component slow_inward_current (ms).
 * CONSTANTS[12] is u_csi in component slow_inward_current (dimensionless).
 * CONSTANTS[13] is k in component slow_inward_current (dimensionless).
 * STATES[2] is w in component slow_inward_current_w_gate (dimensionless).
 * CONSTANTS[14] is tau_w_minus in component slow_inward_current_w_gate (ms).
 * CONSTANTS[15] is tau_w_plus in component slow_inward_current_w_gate (ms).
 * CONSTANTS[16] is IstimStart in component stimulus_protocol (ms).
 * CONSTANTS[17] is IstimEnd in component stimulus_protocol (ms).
 * CONSTANTS[18] is IstimAmplitude in component stimulus_protocol (per_ms).
 * CONSTANTS[19] is IstimPeriod in component stimulus_protocol (ms).
 * CONSTANTS[20] is IstimPulseDuration in component stimulus_protocol (ms).
 * RATES[0] is d/dt u in component membrane (dimensionless).
 * RATES[1] is d/dt v in component fast_inward_current_v_gate (dimensionless).
 * RATES[2] is d/dt w in component slow_inward_current_w_gate (dimensionless).
 */
	double STATES_1[TWO_DIM_SYSTEM_X_SIZE][TWO_DIM_SYSTEM_Y_SIZE][3];
	double STATES_2[TWO_DIM_SYSTEM_X_SIZE][TWO_DIM_SYSTEM_Y_SIZE][3];
	double RATES[3];
	double ALGEBRAIC[8];
	double CONSTANTS[22];

	double G_fi_max[TWO_DIM_SYSTEM_X_SIZE][TWO_DIM_SYSTEM_Y_SIZE];


	void initConsts();//double* CONSTANTS, double* RATES, double *STATES);
//	void computeRates();//double VOI, double* CONSTANTS, double* RATES, double* STATES, double* ALGEBRAIC);
//	void computeVariables();//double VOI, double* CONSTANTS, double* RATES, double* STATES, double* ALGEBRAIC);
//	void computeStates();

	double DX[TWO_DIM_SYSTEM_X_SIZE][TWO_DIM_SYSTEM_Y_SIZE];
	double DY[TWO_DIM_SYSTEM_X_SIZE][TWO_DIM_SYSTEM_Y_SIZE];

	double CUSTOM_VALUE[TWO_DIM_SYSTEM_X_SIZE][TWO_DIM_SYSTEM_Y_SIZE];
	double Min_Custom_Value,Max_Custom_Value;
	void compute_min_max_custom_value();
	double get_custom_value(double Cx, double Cy);

	vector_of_doubles VOLTAGE_HISTORY[TWO_DIM_SYSTEM_X_SIZE][TWO_DIM_SYSTEM_Y_SIZE];

	vector <vector_of_doubles> Middle_Row_Voltage_History;
	void record_potentials();
	void compute_ISIs(long Node_Position);
	vector<long>ISIs;
	vector<long>Activations_Positions;
	long ISIs_Node_Ptr_X;

	void compute_ISIs_XY(int X, int Y);


	double Min_Voltage,Max_Voltage;

	double Min_Diff,Max_Diff_X,Max_Diff_Y;
	void set_initial_coupling();

	int Boundary_Conditions;

	int allocate_tables();
	int free_tables();
	void clear_system();
	void refresh_VW_matrices(); // to avoid drop in efficiency

	void create_spiral(int Slice_Plane); // 0-x,1-y,2-z,3-t

	double* FK3_Activation_Variable_APD;
	double* FK3_Recovery_Variable_APD;
	int FK3_APD_Length;

	double dx,dt;

	double Global_Time;

	void calculate_V1_from_V2();
	void calculate_V2_from_V1();

	double fast_tanh(double x);

	double get_voltage(int X, int Y);
	double get_current(int X, int Y);

	void compute_N_steps(int N);

	int get_color_code(int Source, int X,int Y);

	void stimulate_node(int X,int Y);

	// ASSYMETRIC VOLTAGE MODULATION
	void add_assymetric_modulation();
	bool Add_Assymetric_Modulation;
	double Asm_Length;
	double Asm_Amplitude;
	double Asm_Ratio;

	// SINUSOIDAL CURRENT MODULATION
	void add_current_modulation_1();
	bool Add_Current_Modulation_1;
	double CM1_Length;
	double CM1_Amplitude;

	double Central_Region_Relative_Size;

	// coupling stuff
    double Diff_v1_Number;
	double Diff_v1_Radius;
	double Ring_v1_Width;
	double Ring_v1_PercD;
	double Lines_No_v1;
	double Line_Perc_Leng_v1;
	double Line_Perc_D;
	double Disk_Radius;

	void add_coupling(int Version,bool Add_Rings);

	void stimulate_system(double Cx, double Cy);
	void ablate_system(double Cx, double Cy);


	void set_mi_distribution(double mi1_left,double mi2_left,
							 double mi1_right,double mi2_right,
							 double Ratio);

	void set_mi_breakup_rings(double mi1_min,double mi1_max,
							 double Radius, long Number,bool Middle);

	void set_mi_breakup_landscape(double R, double p, double I,
				double min, double max, int Target_Variable);


	vector <double> calculate_unipolar_voltage_from_surface(int Node_x,long Node_y, long Range);

	// CRITICAL REGIONS SUPPORT
	bool activity_present_check();
	void add_non_conducting_disk(int X,int Y,int Z,int R);
	void add_critical_region(Two_D_system_CR_region_class CR);


    // parameters (dummy parameters)
	double k_par,a,eps,mi1,mi2,b;

};

#endif
