//---------------------------------------------------------------------------

#include <stdlib.h>
#include <math.h>
#include <fstream.h>
#include <vcl.h>

#pragma hdrstop

#include "FHN_4D_system.h"

//---------------------------------------------------------------------------

#pragma package(smart_init)

//---------------------------------------------------------------------------

FHN_4D_system_class::~FHN_4D_system_class()
{
    free_tables();
}
//---------------------------------------------------------------------------

FHN_4D_system_class::FHN_4D_system_class()
{
    Min_Voltage = -2;
    Max_Voltage = 2;

    ni = 0.3;
    gamma = 0.5;
    beta = 0.7;

    dx = 0.1;
    dt = 0.01;

    DX = 0.1;
    DY = 0.1;
    DZ = 0.1;
    DT = 0.1;

    Size_X = 2;
    Size_Y = 2;
    Size_Z = 2;
    Size_T = 2;
    allocate_tables();

    Global_Time=0;

    // Load phase vector
	ifstream dfile;
    char s[3000];
    dfile.open( "FHN_phase.txt" );
    if(dfile==NULL) ShowMessage("Unable to open FHN_phase.txt file");
    else
    {
        dfile >> FHN_APD_Length;
        FHN_Activation_Variable_APD = new double[FHN_APD_Length];
        FHN_Recovery_Variable_APD = new double[FHN_APD_Length];

        for(long i=0;i<FHN_APD_Length;i++)
        {
            dfile >> s; FHN_Activation_Variable_APD[i] = atof(s);
            dfile >> s; FHN_Recovery_Variable_APD[i] = atof(s);
        }
    }

}

//---------------------------------------------------------------------------

int FHN_4D_system_class::allocate_tables()
{

    V1 = (double****) malloc((unsigned)(Size_X)*sizeof(double***));
    V2 = (double****) malloc((unsigned)(Size_X)*sizeof(double***));
    W1 = (double****) malloc((unsigned)(Size_X)*sizeof(double***));
    W2 = (double****) malloc((unsigned)(Size_X)*sizeof(double***));
    if (!V1) exit(0);

    for( int i=0; i < Size_X; i++)
    {
        V1[i] = (double***) malloc((unsigned)(Size_Y)*sizeof(double**));
        V2[i] = (double***) malloc((unsigned)(Size_Y)*sizeof(double**));
        W1[i] = (double***) malloc((unsigned)(Size_Y)*sizeof(double**));
        W2[i] = (double***) malloc((unsigned)(Size_Y)*sizeof(double**));
        if (!V1[i]) exit(0);
    }

    for( int i=0; i<Size_X; i++)
    for( int j=0; j<Size_Y; j++)
      {
            V1[i][j] = (double**) malloc((unsigned)(Size_Z)*sizeof(double*));
            V2[i][j] = (double**) malloc((unsigned)(Size_Z)*sizeof(double*));
            W1[i][j] = (double**) malloc((unsigned)(Size_Z)*sizeof(double*));
            W2[i][j] = (double**) malloc((unsigned)(Size_Z)*sizeof(double*));
            if (!V1[i][j])
      	{
		      exit(0);
      	}
      }

      for( int i=0; i<Size_X; i++)
      for( int j=0; j<Size_Y; j++)
      for( int k=0; k<Size_Z; k++)
      {
            V1[i][j][k] = (double*) malloc((unsigned)(Size_T)*sizeof(double));
            V2[i][j][k] = (double*) malloc((unsigned)(Size_T)*sizeof(double));
            W1[i][j][k] = (double*) malloc((unsigned)(Size_T)*sizeof(double));
            W2[i][j][k] = (double*) malloc((unsigned)(Size_T)*sizeof(double));
            if (!V1[i][j][k])
      	{
		      exit(0);
      	}
      }
     clear_system();

     return 1;
}

//---------------------------------------------------------------------------

void FHN_4D_system_class::clear_system()
{
    // Clear grid
    for( int i=0; i<Size_X; i++)
    for( int j=0; j<Size_Y; j++)
    for( int k=0; k<Size_Z; k++)
    for( int l=0; l<Size_T; l++)
    {

    V1[i][j][k][l] = -1.1;
    V2[i][j][k][l] = -1.1;
    W1[i][j][k][l] = -0.6;
    W2[i][j][k][l] = -0.6;

    }

 }

//---------------------------------------------------------------------------

int FHN_4D_system_class::free_tables()
{
      for( int i=0; i<Size_X; i++)
      for( int j=0; j<Size_Y; j++)
      for( int k=0; k<Size_Z; k++)
      {
            free( (double*) ( V1[i][j][k] ) );
            free( (double*) ( V2[i][j][k] ) );
            free( (double*) ( W1[i][j][k] ) );
            free( (double*) ( W2[i][j][k] ) );
      }


      for( int i=0; i<Size_X; i++)
      for( int j=0; j<Size_Y; j++)
      {
            free( (double**) ( V1[i][j] ) );
            free( (double**) ( V2[i][j] ) );
            free( (double**) ( W1[i][j] ) );
            free( (double**) ( W2[i][j] ) );
      }

      for( int i=0; i < Size_Z; i++)
      {
            free( (double***) (V1[i]) );
            free( (double***) (V2[i]) );
            free( (double***) (W1[i]) );
            free( (double***) (W2[i]) );
      }

      free( (double****) (V1) );
      free( (double****) (V2) );
      free( (double****) (W1) );
      free( (double****) (W2) );

    return 1;

}
//---------------------------------------------------------------------------

void FHN_4D_system_class::compute_N_steps(int N)
{
    for(int n=0;n<N;n++)
    {
        calculate_V1_from_V2_fhn();
        calculate_V2_from_V1_fhn();
        Global_Time = Global_Time + dt;
    }
}

//---------------------------------------------------------------------------
/*
void FHN_4D_system_class::calculate_V2_from_V1_fhn()
{
//fff21
      double e,r,k1,k2,w = 0.5,xp,yp;
      double diff_term;
      double DXx = DX/(dx*dx);
      double DYx = DY/(dx*dx);
      double DZx = DZ/(dx*dx);
      double DTx = DT/(dx*dx);

      // matrix V without boundaries
      for(int i = 1; i < Size_X - 1; i++ )
      for(int j = 1; j < Size_Y - 1; j++ )
      for(int k = 1; k < Size_Z - 1; k++ )
      for(int l = 1; l < Size_T - 1; l++ )
      {
        diff_term =
            DTx*( V1[i  ][j  ][k  ][l+1] + V1[i  ][j  ][k  ][l-1] - 2*V1[i][j][k][l])+
            DZx*( V1[i  ][j  ][k+1][l  ] + V1[i  ][j  ][k-1][l  ] - 2*V1[i][j][k][l])+
            DYx*( V1[i  ][j+1][k  ][l  ] + V1[i  ][j-1][k  ][l  ] - 2*V1[i][j][k][l])+
            DXx*( V1[i+1][j  ][k  ][l  ] + V1[i-1][j  ][k  ][l  ] - 2*V1[i][j][k][l]);

        // Runge Kutta for e variable
        k1 = (V1[i][j][k][l]-0.333*std::pow(V1[i][j][k][l],3)-W1[i][j][k][l])/ni;
        e = V1[i][j][k][l] + k1*dt/(0.5*w);
        r = W1[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V2[i][j][k][l] = V1[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);

        // Runge Kutta for r variable
        k1 = ni*(V1[i][j][k][l] + beta - gamma*W1[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W2[i][j][k][l] = W1[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );
      }

      //------------------------------------------------------------------
      // X side L of the system
      //------------------------------------------------------------------
      int i = 0;
      for(int j = 0; j < Size_Y; j++ )
      for(int k = 0; k < Size_Z; k++ )
      for(int l = 0; l < Size_T; l++ )
      {
        diff_term = DXx*( V1[i+1][j ][k ][l ] - V1[i][j][k][l] );
        // Runge Kutta for e variable
        k1 = (V1[i][j][k][l]-0.333*std::pow(V1[i][j][k][l],3)-W1[i][j][k][l])/ni;
        e = V1[i][j][k][l] + k1*dt/(0.5*w);
        r = W1[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V2[i][j][k][l] = V1[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);
        // Runge Kutta for r variable
        k1 = ni*(V1[i][j][k][l] + beta - gamma*W1[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W2[i][j][k][l] = W1[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );
      }

      // X side R of the system
      i = Size_X-1;
      for(int j = 0; j < Size_Y; j++ )
      for(int k = 0; k < Size_Z; k++ )
      for(int l = 0; l < Size_T; l++ )
      {
        diff_term = DXx*( V1[i-1][j ][k ][l ] - V1[i][j][k][l] );
        // Runge Kutta for e variable
        k1 = (V1[i][j][k][l]-0.333*std::pow(V1[i][j][k][l],3)-W1[i][j][k][l])/ni;
        e = V1[i][j][k][l] + k1*dt/(0.5*w);
        r = W1[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V2[i][j][k][l] = V1[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);
        // Runge Kutta for r variable
        k1 = ni*(V1[i][j][k][l] + beta - gamma*W1[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W2[i][j][k][l] = W1[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );
      }

      //------------------------------------------------------------------
      // Y side L of the system
      //------------------------------------------------------------------
      int j = 0;
      for(int i = 0; i < Size_X; i++ )
      for(int k = 0; k < Size_Z; k++ )
      for(int l = 0; l < Size_T; l++ )
      {
        diff_term = DYx*( V1[i][j+1][k ][l ] - V1[i][j][k][l] );
        // Runge Kutta for e variable
        k1 = (V1[i][j][k][l]-0.333*std::pow(V1[i][j][k][l],3)-W1[i][j][k][l])/ni;
        e = V1[i][j][k][l] + k1*dt/(0.5*w);
        r = W1[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V2[i][j][k][l] = V1[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);
        // Runge Kutta for r variable
        k1 = ni*(V1[i][j][k][l] + beta - gamma*W1[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W2[i][j][k][l] = W1[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );
      }

      // Y side R of the system
      j = Size_Y-1;
      for(int i = 0; i < Size_X; i++ )
      for(int k = 0; k < Size_Z; k++ )
      for(int l = 0; l < Size_T; l++ )
      {
        diff_term = DYx*( V1[i][j-1][k ][l ] - V1[i][j][k][l] );
        // Runge Kutta for e variable
        k1 = (V1[i][j][k][l]-0.333*std::pow(V1[i][j][k][l],3)-W1[i][j][k][l])/ni;
        e = V1[i][j][k][l] + k1*dt/(0.5*w);
        r = W1[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V2[i][j][k][l] = V1[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);
        // Runge Kutta for r variable
        k1 = ni*(V1[i][j][k][l] + beta - gamma*W1[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W2[i][j][k][l] = W1[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );
      }

      //------------------------------------------------------------------
      // Z side L of the system
      //------------------------------------------------------------------
      if( Size_Z > 1 )
      {

      int k = 0;
      for(int i = 0; i < Size_X; i++ )
      for(int j = 0; j < Size_Y; j++ )
      for(int l = 0; l < Size_T; l++ )
      {
        diff_term = DZx*( V1[i][j][k+1][l ] - V1[i][j][k][l] );
        // Runge Kutta for e variable
        k1 = (V1[i][j][k][l]-0.333*std::pow(V1[i][j][k][l],3)-W1[i][j][k][l])/ni;
        e = V1[i][j][k][l] + k1*dt/(0.5*w);
        r = W1[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V2[i][j][k][l] = V1[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);
        // Runge Kutta for r variable
        k1 = ni*(V1[i][j][k][l] + beta - gamma*W1[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W2[i][j][k][l] = W1[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );
      }
      // Z side R of the system
      k = Size_Z-1;
      for(int i = 0; i < Size_X; i++ )
      for(int j = 0; j < Size_Y; j++ )
      for(int l = 0; l < Size_T; l++ )
      {
        diff_term = DZx*( V1[i][j][k-1][l ] - V1[i][j][k][l] );
        // Runge Kutta for e variable
        k1 = (V1[i][j][k][l]-0.333*std::pow(V1[i][j][k][l],3)-W1[i][j][k][l])/ni;
        e = V1[i][j][k][l] + k1*dt/(0.5*w);
        r = W1[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V2[i][j][k][l] = V1[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);
        // Runge Kutta for r variable
        k1 = ni*(V1[i][j][k][l] + beta - gamma*W1[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W2[i][j][k][l] = W1[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );
      }
      }
      //------------------------------------------------------------------
      // T side L of the system
      //------------------------------------------------------------------
      if( Size_T > 1 )
      {

      int l = 0;
      for(int  i = 0; i < Size_X; i++ )
      for(int  j = 0; j < Size_Y; j++ )
      for(int  k = 0; k < Size_Z; k++ )
      {
        diff_term = DTx*( V1[i][j][k][l+1] - V1[i][j][k][l] );
        // Runge Kutta for e variable
        k1 = (V1[i][j][k][l]-0.333*std::pow(V1[i][j][k][l],3)-W1[i][j][k][l])/ni;
        e = V1[i][j][k][l] + k1*dt/(0.5*w);
        r = W1[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V2[i][j][k][l] = V1[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);
        // Runge Kutta for r variable
        k1 = ni*(V1[i][j][k][l] + beta - gamma*W1[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W2[i][j][k][l] = W1[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );
      }

      // T side R of the system
      l = Size_T-1;
      for(int i = 0; i < Size_X; i++ )
      for(int j = 0; j < Size_Y; j++ )
      for(int k = 0; k < Size_Z; k++ )
      {
        diff_term = DTx*( V1[i][j][k][l-1] - V1[i][j][k][l] );
        // Runge Kutta for e variable
        k1 = (V1[i][j][k][l]-0.333*std::pow(V1[i][j][k][l],3)-W1[i][j][k][l])/ni;
        e = V1[i][j][k][l] + k1*dt/(0.5*w);
        r = W1[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V2[i][j][k][l] = V1[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);
        // Runge Kutta for r variable
        k1 = ni*(V1[i][j][k][l] + beta - gamma*W1[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W2[i][j][k][l] = W1[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );
      }
      }
}

//------------------------------------------------------------------------------

void FHN_4D_system_class::calculate_V1_from_V2_fhn()
{
//fff12
      double e,r,k1,k2,w = 0.5,xp,yp;
      double diff_term;
      double DXx = DX/(dx*dx);
      double DYx = DY/(dx*dx);
      double DZx = DZ/(dx*dx);
      double DTx = DT/(dx*dx);

      // matrix V without boundaries
      for(int i = 1; i < Size_X - 1; i++ )
      for(int j = 1; j < Size_Y - 1; j++ )
      for(int k = 1; k < Size_Z - 1; k++ )
      for(int l = 1; l < Size_T - 1; l++ )
      {
        diff_term =
            DTx*( V2[i  ][j  ][k  ][l+1] + V2[i  ][j  ][k  ][l-1] - 2*V2[i][j][k][l])+
            DZx*( V2[i  ][j  ][k+1][l  ] + V2[i  ][j  ][k-1][l  ] - 2*V2[i][j][k][l])+
            DYx*( V2[i  ][j+1][k  ][l  ] + V2[i  ][j-1][k  ][l  ] - 2*V2[i][j][k][l])+
            DXx*( V2[i+1][j  ][k  ][l  ] + V2[i-1][j  ][k  ][l  ] - 2*V2[i][j][k][l]);

        // Runge Kutta for e variable
        k1 = (V2[i][j][k][l]-0.333*std::pow(V2[i][j][k][l],3)-W2[i][j][k][l])/ni;
        e = V2[i][j][k][l] + k1*dt/(0.5*w);
        r = W2[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V1[i][j][k][l] = V2[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);

        // Runge Kutta for r variable
        k1 = ni*(V2[i][j][k][l] + beta - gamma*W2[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W1[i][j][k][l] = W2[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );

      }

      //------------------------------------------------------------------
      // X side L of the system
      //------------------------------------------------------------------
      int i = 0;
      for(int j = 0; j < Size_Y; j++ )
      for(int k = 0; k < Size_Z; k++ )
      for(int l = 0; l < Size_T; l++ )
      {
        diff_term = DXx*( V2[i+1][j ][k ][l ] - V2[i][j][k][l] );
        // Runge Kutta for e variable
        k1 = (V2[i][j][k][l]-0.333*std::pow(V2[i][j][k][l],3)-W2[i][j][k][l])/ni;
        e = V2[i][j][k][l] + k1*dt/(0.5*w);
        r = W2[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V1[i][j][k][l] = V2[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);
        // Runge Kutta for r variable
        k1 = ni*(V2[i][j][k][l] + beta - gamma*W2[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W1[i][j][k][l] = W2[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );
      }

      // X side R of the system
      i = Size_X-1;
      for(int j = 0; j < Size_Y; j++ )
      for(int k = 0; k < Size_Z; k++ )
      for(int l = 0; l < Size_T; l++ )
      {
        diff_term = DXx*( V2[i-1][j ][k ][l ] - V2[i][j][k][l] );
        // Runge Kutta for e variable
        k1 = (V2[i][j][k][l]-0.333*std::pow(V2[i][j][k][l],3)-W2[i][j][k][l])/ni;
        e = V2[i][j][k][l] + k1*dt/(0.5*w);
        r = W2[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V1[i][j][k][l] = V2[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);
        // Runge Kutta for r variable
        k1 = ni*(V2[i][j][k][l] + beta - gamma*W2[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W1[i][j][k][l] = W2[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );
      }

      //------------------------------------------------------------------
      // Y side L of the system
      //------------------------------------------------------------------
      int j = 0;
      for(int i = 0; i < Size_X; i++ )
      for(int k = 0; k < Size_Z; k++ )
      for(int l = 0; l < Size_T; l++ )
      {
        diff_term = DYx*( V2[i][j+1][k ][l ] - V2[i][j][k][l] );
        // Runge Kutta for e variable
        k1 = (V2[i][j][k][l]-0.333*std::pow(V2[i][j][k][l],3)-W2[i][j][k][l])/ni;
        e = V2[i][j][k][l] + k1*dt/(0.5*w);
        r = W2[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V1[i][j][k][l] = V2[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);
        // Runge Kutta for r variable
        k1 = ni*(V2[i][j][k][l] + beta - gamma*W2[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W1[i][j][k][l] = W2[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );
      }

      // Y side R of the system
      j = Size_Y-1;
      for(int i = 0; i < Size_X; i++ )
      for(int k = 0; k < Size_Z; k++ )
      for(int l = 0; l < Size_T; l++ )
      {
        diff_term = DYx*( V2[i][j-1][k ][l ] - V2[i][j][k][l] );
        // Runge Kutta for e variable
        k1 = (V2[i][j][k][l]-0.333*std::pow(V2[i][j][k][l],3)-W2[i][j][k][l])/ni;
        e = V2[i][j][k][l] + k1*dt/(0.5*w);
        r = W2[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V1[i][j][k][l] = V2[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);
        // Runge Kutta for r variable
        k1 = ni*(V2[i][j][k][l] + beta - gamma*W2[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W1[i][j][k][l] = W2[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );
      }

      //------------------------------------------------------------------
      // Z side L of the system
      //------------------------------------------------------------------
      if( Size_Z > 1 )
      {

      int k = 0;
      for(int i = 0; i < Size_X; i++ )
      for(int j = 0; j < Size_Y; j++ )
      for(int l = 0; l < Size_T; l++ )
      {
        diff_term = DZx*( V2[i][j][k+1][l ] - V2[i][j][k][l] );
        // Runge Kutta for e variable
        k1 = (V2[i][j][k][l]-0.333*std::pow(V2[i][j][k][l],3)-W2[i][j][k][l])/ni;
        e = V2[i][j][k][l] + k1*dt/(0.5*w);
        r = W2[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V1[i][j][k][l] = V2[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);
        // Runge Kutta for r variable
        k1 = ni*(V2[i][j][k][l] + beta - gamma*W2[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W1[i][j][k][l] = W2[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );
      }
      // Z side R of the system
      k = Size_Z-1;
      for(int i = 0; i < Size_X; i++ )
      for(int j = 0; j < Size_Y; j++ )
      for(int l = 0; l < Size_T; l++ )
      {
        diff_term = DZx*( V2[i][j][k-1][l ] - V2[i][j][k][l] );
        // Runge Kutta for e variable
        k1 = (V2[i][j][k][l]-0.333*std::pow(V2[i][j][k][l],3)-W2[i][j][k][l])/ni;
        e = V2[i][j][k][l] + k1*dt/(0.5*w);
        r = W2[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V1[i][j][k][l] = V2[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);
        // Runge Kutta for r variable
        k1 = ni*(V2[i][j][k][l] + beta - gamma*W2[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W1[i][j][k][l] = W2[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );
      }

      }
      //------------------------------------------------------------------
      // T side L of the system
      //------------------------------------------------------------------
      if( Size_T > 1 )
      {

      int l = 0;
      for(int  i = 0; i < Size_X; i++ )
      for(int  j = 0; j < Size_Y; j++ )
      for(int  k = 0; k < Size_Z; k++ )
      {
        diff_term = DTx*( V2[i][j][k][l+1] - V2[i][j][k][l] );
        // Runge Kutta for e variable
        k1 = (V2[i][j][k][l]-0.333*std::pow(V2[i][j][k][l],3)-W2[i][j][k][l])/ni;
        e = V2[i][j][k][l] + k1*dt/(0.5*w);
        r = W2[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V1[i][j][k][l] = V2[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);
        // Runge Kutta for r variable
        k1 = ni*(V2[i][j][k][l] + beta - gamma*W2[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W1[i][j][k][l] = W2[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );
      }

      // T side R of the system
      l = Size_T-1;
      for(int i = 0; i < Size_X; i++ )
      for(int j = 0; j < Size_Y; j++ )
      for(int k = 0; k < Size_Z; k++ )
      {
        diff_term = DTx*( V2[i][j][k][l-1] - V2[i][j][k][l] );
        // Runge Kutta for e variable
        k1 = (V2[i][j][k][l]-0.333*std::pow(V2[i][j][k][l],3)-W2[i][j][k][l])/ni;
        e = V2[i][j][k][l] + k1*dt/(0.5*w);
        r = W2[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V1[i][j][k][l] = V2[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);
        // Runge Kutta for r variable
        k1 = ni*(V2[i][j][k][l] + beta - gamma*W2[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W1[i][j][k][l] = W2[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );
      }
      }


}
*/
//------------------------------------------------------------------------------

void FHN_4D_system_class::calculate_V2_from_V1_fhn()
{
//fff21
      int i,j,k,l;
      double e,r,k1,k2,w = 0.5,xp,yp;
      double diff_term;
      double DXx = DX/(dx*dx);
      double DYx = DY/(dx*dx);
      double DZx = DZ/(dx*dx);
      double DTx = DT/(dx*dx);

      // all matrix
      for( i = 0; i < Size_X; i++ )
      for( j = 0; j < Size_Y; j++ )
      for( k = 0; k < Size_Z; k++ )
      for( l = 0; l < Size_T; l++ )
      {

      diff_term = 0;

      if(l > 1 )
      diff_term += DTx*( V1[i  ][j  ][k  ][l-1] - V1[i][j][k][l] );
      if(l+1 < Size_T )
      diff_term += DTx*( V1[i  ][j  ][k  ][l+1] - V1[i][j][k][l] );

      if(k > 1 )
      diff_term += DZx*( V1[i  ][j  ][k-1][l ] - V1[i][j][k][l] );
      if(k+1 < Size_Z )
      diff_term += DZx*( V1[i  ][j  ][k+1][l ] - V1[i][j][k][l] );

      if(j > 1 )
      diff_term += DYx*( V1[i  ][j-1][k ][l ] - V1[i][j][k][l] );
      if(j+1 < Size_Y )
      diff_term += DYx*( V1[i  ][j+1][k ][l ] - V1[i][j][k][l] );

      if(i > 1 )
      diff_term += DXx*( V1[i-1][j ][k ][l ] - V1[i][j][k][l] );
      if(i+1 < Size_X )
      diff_term += DXx*( V1[i+1][j ][k ][l ] - V1[i][j][k][l] );

        // Runge Kutta for e variable
        k1 = (V1[i][j][k][l]-0.333*std::pow(V1[i][j][k][l],3)-W1[i][j][k][l])/ni;
        e = V1[i][j][k][l] + k1*dt/(0.5*w);
        r = W1[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V2[i][j][k][l] = V1[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);

        // Runge Kutta for r variable
        k1 = ni*(V1[i][j][k][l] + beta - gamma*W1[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W2[i][j][k][l] = W1[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );

      }
}

//------------------------------------------------------------------------------

void FHN_4D_system_class::calculate_V1_from_V2_fhn()
{
//fff12
      int i,j,k,l;
      double e,r,k1,k2,w = 0.5,xp,yp;
      double diff_term;
      double DXx = DX/(dx*dx);
      double DYx = DY/(dx*dx);
      double DZx = DZ/(dx*dx);
      double DTx = DT/(dx*dx);

      for( i = 0; i < Size_X; i++ )
      for( j = 0; j < Size_Y; j++ )
      for( k = 0; k < Size_Z; k++ )
      for( l = 0; l < Size_T; l++ )
      {

      diff_term = 0;

      if(l > 1 )
      diff_term += DT*( V2[i  ][j  ][k  ][l-1] - V2[i][j][k][l] );
      if(l+1 < Size_T )
      diff_term += DT*( V2[i  ][j  ][k  ][l+1] - V2[i][j][k][l] );

      if(k > 1 )
      diff_term += DZ*( V2[i  ][j  ][k-1][l ] - V2[i][j][k][l] );
      if(k+1 < Size_Z )
      diff_term += DZ*( V2[i  ][j  ][k+1][l ] - V2[i][j][k][l] );

      if(j > 1 )
      diff_term += DY*( V2[i  ][j-1][k ][l ] - V2[i][j][k][l] );
      if(j+1 < Size_Y )
      diff_term += DY*( V2[i  ][j+1][k ][l ] - V2[i][j][k][l] );

      if(i > 1 )
      diff_term += DX*( V2[i-1][j ][k ][l ] - V2[i][j][k][l] );
      if(i+1 < Size_X )
      diff_term += DX*( V2[i+1][j ][k ][l ] - V2[i][j][k][l] );

        // Runge Kutta for e variable
        k1 = (V2[i][j][k][l]-0.333*std::pow(V2[i][j][k][l],3)-W2[i][j][k][l])/ni;
        e = V2[i][j][k][l] + k1*dt/(0.5*w);
        r = W2[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V1[i][j][k][l] = V2[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);

        // Runge Kutta for r variable
        k1 = ni*(V2[i][j][k][l] + beta - gamma*W2[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W1[i][j][k][l] = W2[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );

      }

}

//------------------------------------------------------------------------------

/*
void FHN_4D_system_class::calculate_V2_from_V1_fhn()
{
//fff21
      int i,j,k,l;
      double e,r,k1,k2,w = 0.5,xp,yp;
      double D1 = DX/(dx*dx),diff_term;

      // matrix V without boundaries
      for( i = 1; i < Size_X - 1; i++ )
      for( j = 1; j < Size_Y - 1; j++ )
      for( k = 1; k < Size_Z - 1; k++ )
      for( l = 1; l < Size_T - 1; l++ )
      {

        diff_term =
            D1*( V1[i  ][j  ][k  ][l+1] + V1[i  ][j  ][k  ][l-1] - 2*V1[i][j][k][l])+
            D1*( V1[i  ][j  ][k+1][l  ] + V1[i  ][j  ][k-1][l  ] - 2*V1[i][j][k][l])+
            D1*( V1[i  ][j+1][k  ][l  ] + V1[i  ][j-1][k  ][l  ] - 2*V1[i][j][k][l])+
            D1*( V1[i+1][j  ][k  ][l  ] + V1[i-1][j  ][k  ][l  ] - 2*V1[i][j][k][l]);

//        diff_term = D1*(
//            V1[i  ][j  ][k  ][l+1] + V1[i  ][j  ][k  ][l-1] +
//            V1[i  ][j  ][k+1][l  ] + V1[i  ][j  ][k-1][l  ] +
//            V1[i  ][j+1][k  ][l  ] + V1[i  ][j-1][k  ][l  ] +
//            V1[i+1][j  ][k  ][l  ] + V1[i-1][j  ][k  ][l  ] +
//            - 8*V1[i][j][k][l] );

        // Runge Kutta for e variable
        k1 = (V1[i][j][k][l]-0.333*std::pow(V1[i][j][k][l],3)-W1[i][j][k][l])/ni;
        e = V1[i][j][k][l] + k1*dt/(0.5*w);
        r = W1[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V2[i][j][k][l] = V1[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);

        // Runge Kutta for r variable
        k1 = ni*(V1[i][j][k][l] + beta - gamma*W1[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W2[i][j][k][l] = W1[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );

      }

      //  zero flux boundary conditions

      // "T" sides
      for( i = 1; i < Size_X - 1; i++ )
      for( j = 1; j < Size_Y - 1; j++ )
      for( k = 1; k < Size_Z - 1; k++ )
      {
            V2[i][j][k][0] = V2[i][j][k][1];
            V2[i][j][k][Size_T-1] = V2[i][j][k][Size_T-2];

            W2[i][j][k][0] = W2[i][j][k][1];
            W2[i][j][k][Size_T-1] = W2[i][j][k][Size_T-2];
      }

      // "Z" sides
      for( i = 1; i < Size_X - 1; i++ )
      for( j = 1; j < Size_Y - 1; j++ )
      for( l = 1; l < Size_T - 1; l++ )
      {
            V2[i][j][0][l] = V2[i][j][1][l];
            V2[i][j][Size_Z-1][l] = V2[i][j][Size_Z-2][l];

            W2[i][j][0][l] = W2[i][j][1][l];
            W2[i][j][Size_Z-1][l] = W2[i][j][Size_Z-2][l];
      }

      // "Y" sides
      for( i = 1; i < Size_X - 1; i++ )
      for( k = 1; k < Size_Z - 1; k++ )
      for( l = 1; l < Size_T - 1; l++ )
      {
            V2[i][0][k][l] = V2[i][1][k][l];
            V2[i][Size_Y-1][k][l] = V2[i][Size_Y-2][k][l];

            W2[i][0][k][l] = W2[i][1][k][l];
            W2[i][Size_Y-1][k][l] = W2[i][Size_Y-2][k][l];
      }

      // "X" sides
      for( j = 1; j < Size_Y - 1; j++ )
      for( k = 1; k < Size_Z - 1; k++ )
      for( l = 1; l < Size_T - 1; l++ )
      {
            V2[0][j][k][l] = V2[1][j][k][l];
            V2[Size_X-1][j][k][l] = V2[Size_X-2][j][k][l];

            W2[0][j][k][l] = W2[1][j][k][l];
            W2[Size_X-1][j][k][l] = W2[Size_X-2][j][k][l];
      }

}

//------------------------------------------------------------------------------

void FHN_4D_system_class::calculate_V1_from_V2_fhn()
{
//fff12
      int i,j,k,l;
      double e,r,k1,k2,w = 0.5,xp,yp;
      double D1 = DX/(dx*dx),diff_term;

      // matrix V without boundaries
      for( i = 1; i < Size_X - 1; i++ )
      for( j = 1; j < Size_Y - 1; j++ )
      for( k = 1; k < Size_Z - 1; k++ )
      for( l = 1; l < Size_T - 1; l++ )
      {

        diff_term =
            D1*( V2[i  ][j  ][k  ][l+1] + V2[i  ][j  ][k  ][l-1] - 2*V2[i][j][k][l])+
            D1*( V2[i  ][j  ][k+1][l  ] + V2[i  ][j  ][k-1][l  ] - 2*V2[i][j][k][l])+
            D1*( V2[i  ][j+1][k  ][l  ] + V2[i  ][j-1][k  ][l  ] - 2*V2[i][j][k][l])+
            D1*( V2[i+1][j  ][k  ][l  ] + V2[i-1][j  ][k  ][l  ] - 2*V2[i][j][k][l]);

//        diff_term = D1*(
//            V2[i  ][j  ][k  ][l+1] + V2[i  ][j  ][k  ][l-1] +
//            V2[i  ][j  ][k+1][l  ] + V2[i  ][j  ][k-1][l  ] +
//            V2[i  ][j+1][k  ][l  ] + V2[i  ][j-1][k  ][l  ] +
//            V2[i+1][j  ][k  ][l  ] + V2[i-1][j  ][k  ][l  ] +
//            - 8*V2[i][j][k][l] );

        // Runge Kutta for e variable
        k1 = (V2[i][j][k][l]-0.333*std::pow(V2[i][j][k][l],3)-W2[i][j][k][l])/ni;
        e = V2[i][j][k][l] + k1*dt/(0.5*w);
        r = W2[i][j][k][l] + dt/(0.5*w);
        k2 = (e-0.333*pow(e,3)-r)/ni;
        V1[i][j][k][l] = V2[i][j][k][l] +
            + dt*( (1-w)*k1 + w*k2 + diff_term);

        // Runge Kutta for r variable
        k1 = ni*(V2[i][j][k][l] + beta - gamma*W2[i][j][k][l]);
        k2 = ni*(e + beta - gamma*r);
        W1[i][j][k][l] = W2[i][j][k][l] + dt*( (1-w)*k1 + w*k2 );

      }

      //  zero flux boundary conditions

      // "T" sides
      for( i = 1; i < Size_X - 1; i++ )
      for( j = 1; j < Size_Y - 1; j++ )
      for( k = 1; k < Size_Z - 1; k++ )
      {
            V1[i][j][k][0] = V1[i][j][k][1];
            V1[i][j][k][Size_T-1] = V1[i][j][k][Size_T-2];

            W1[i][j][k][0] = W1[i][j][k][1];
            W1[i][j][k][Size_T-1] = W1[i][j][k][Size_T-2];
      }

      // "Z" sides
      for( i = 1; i < Size_X - 1; i++ )
      for( j = 1; j < Size_Y - 1; j++ )
      for( l = 1; l < Size_T - 1; l++ )
      {
            V1[i][j][0][l] = V1[i][j][1][l];
            V1[i][j][Size_Z-1][l] = V1[i][j][Size_Z-2][l];

            W1[i][j][0][l] = W1[i][j][1][l];
            W1[i][j][Size_Z-1][l] = W1[i][j][Size_Z-2][l];
      }

      // "Y" sides
      for( i = 1; i < Size_X - 1; i++ )
      for( k = 1; k < Size_Z - 1; k++ )
      for( l = 1; l < Size_T - 1; l++ )
      {
            V1[i][0][k][l] = V1[i][1][k][l];
            V1[i][Size_Y-1][k][l] = V1[i][Size_Y-2][k][l];

            W1[i][0][k][l] = W1[i][1][k][l];
            W1[i][Size_Y-1][k][l] = W1[i][Size_Y-2][k][l];
      }

      // "X" sides
      for( j = 1; j < Size_Y - 1; j++ )
      for( k = 1; k < Size_Z - 1; k++ )
      for( l = 1; l < Size_T - 1; l++ )
      {
            V1[0][j][k][l] = V1[1][j][k][l];
            V1[Size_X-1][j][k][l] = V1[Size_X-2][j][k][l];

            W1[0][j][k][l] = W1[1][j][k][l];
            W1[Size_X-1][j][k][l] = W1[Size_X-2][j][k][l];
      }

}
*/
//------------------------------------------------------------------------------


void FHN_4D_system_class::create_spiral(int Slice_Plane) // 0-xy,
{
    double wn,r,fi,phase,x,y,d;
    double cx,cy;
    long n;

    // winding number
    wn = 15.0;

    clear_system();

    cx = Size_X/2;
    cy = Size_Y/2;

    if( Slice_Plane == 0 ) // spiral wave in XY plane
    for( int i=0;i<Size_X; i++ )
    for( int j=0;j<Size_Y; j++ )
    for( int k=0;k<Size_Z; k++ )
    for( int l=0;l<Size_T; l++ )
    {
        // distance from center of the spiral in dx units
        r = std::sqrt( std::pow(i-cx,2) + std::pow(j-cy,2));

        x = i-cx;
        y = j-cy;

        if( i-cx != 0.0 )
        {
            d = atan(fabs(y/x));

            // 1st quarter
            if( x >= 0 && y >= 0 )
                fi = d;

            // 2nd quarter
            if( x <= 0 && y >= 0 )
                fi = M_PI - d;

            // 3rd quarter
            if( x <= 0 && y <= 0 )
                fi = M_PI + d;

            // 4th quarter
            if( x >= 0 && y <= 0 )
                fi = 2.0*M_PI - d;
        }
        else
        {
            if( j-0.5*Size_Y > 0.0 )
                 fi = M_PI_2;
            else
                 fi = 3.0*M_PI_2;
        }

        fi += 0.55;

        // find the greatest n such that r > k*fi + 2pi*k*n
        if(wn*fi!=0)
            n = floor( (r-wn*fi)/(2.0*M_PI*wn) );
        else
            n = 0;

        phase = fabs(r-wn*fi-2.0*wn*M_PI*n)/(2.0*wn*M_PI);
        int m = (int)((1.0-phase)*(FHN_APD_Length-2));

        V1[i][j][k][l] = FHN_Activation_Variable_APD[m];
        V2[i][j][k][l] = FHN_Activation_Variable_APD[m];
        W1[i][j][k][l] = FHN_Recovery_Variable_APD[m];
        W2[i][j][k][l] = FHN_Recovery_Variable_APD[m];
    }


}

//---------------------------------------------------------------------------
int FHN_4D_system_class::get_color_code(int X,int Y,int Z,int T)
{
    return 255*(V1[X][Y][Z][T]-Min_Voltage)/(Max_Voltage-Min_Voltage);
}

//---------------------------------------------------------------------------

void FHN_4D_system_class::stimulate_node(int X,int Y,int Z,int T)
{
    V1[X][Y][Z][T]=1;
    V2[X][Y][Z][T]=1;
}

//---------------------------------------------------------------------------

void FHN_4D_system_class::record_potentials()
{
    int j = Size_Y/2;
    int k = Size_Z/2;
    int l = Size_T/2;
    for( int i=0; i<Size_X; i++)
        Middle_Row_Voltage_History[i].DVector.push_back(V1[i][j][k][l]);
}

//---------------------------------------------------------------------------

void FHN_4D_system_class::compute_ISIs(long Node_Position)
{
    ISIs_Node_Ptr_X = Node_Position;
    ISIs.clear();

    double Threshold = 0.5;
    double prev=0,curr=0;

    if( Node_Position >= 0 && Node_Position < Size_X )
    for(long t=1;t<Middle_Row_Voltage_History[Node_Position].DVector.size()-1;t++)
    if( Middle_Row_Voltage_History[Node_Position].DVector[t-1] < Threshold )
    if( Middle_Row_Voltage_History[Node_Position].DVector[t+1] > Threshold )
    {
        curr = t;

        if( prev != 0 )
            ISIs.push_back(curr-prev);

        prev = curr;

        t+=10; // jump in time forward
    }

}

//---------------------------------------------------------------------------

int FHN_4D_system_class::save_object(ofstream* dfile)
{
    dfile[0] << " version_1 ";

    dfile[0] << Size_X << " ";
    dfile[0] << Size_Y << " ";
    dfile[0] << Size_Z << " ";
    dfile[0] << Size_T << " ";

}
//---------------------------------------------------------------------------

int FHN_4D_system_class::load_object(ifstream* dfile)
{
    char string[2000];

    dfile[0] >> string;

    if( !strcmp(string,"version_1") )
    {

    free_tables();
    dfile[0] >> Size_X;
    dfile[0] >> Size_Y;
    dfile[0] >> Size_Z;
    dfile[0] >> Size_T;
    allocate_tables();

    }
}

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------


