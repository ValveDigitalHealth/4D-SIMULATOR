#include <stdlib.h>
#include <math.h>
#include <fstream>
#include <vcl.h>
#include "TP1A_2D_system.h"

#include "Two_D_system_CR_region_class.h"


#pragma hdrstop

//---------------------------------------------------------------------------
#pragma package(smart_init)

//---------------------------------------------------------------------------

TP1A_2D_system_class::~TP1A_2D_system_class()
{

}
//---------------------------------------------------------------------------

TP1A_2D_system_class::TP1A_2D_system_class()
{
	Min_Diff = 0;
	Max_Diff_X = 0.2;
	Max_Diff_Y = 0.2;

// breakup

	a = 0.1;
	k_par = 8;
	eps = 0.01;
	mi1 = 0.05;
	mi2 = 0.3;
	b = 0.1;

  // stable spiral parameters
	mi1 = 0.2;

/* self-termination, zero-flux, 80x80
	a = 0.1;
	k_par = 8;
	eps = 0.01;
	mi1 = 0.1;
	mi2 = 0.3;
	b = 0.1;
*/

// standard parameters
/*
	a = 0.1;
	k_par = 8;
	eps = 0.01;
	mi1 = 0.2;
	mi2 = 0.3;
	b = 0.1;
*/

	dx = 0.2;
	dt = 0.0;  // it is set in main screen!
//	dt = 0.002;    // slow for animations

	Size_X = TWO_DIM_SYSTEM_X_SIZE;
	Size_Y = TWO_DIM_SYSTEM_Y_SIZE;

	allocate_tables();

	Global_Time=0;

	// Load phase vector
	ifstream dfile;
	char s[3000];
	dfile.open( "TP1A_phase.txt" );
	if(dfile==NULL) ShowMessage("Unable to open TP1A_phase.txt file");
	else
	{
		dfile >> TP1A_APD_Length;
		TP1A_Activation_Variable_APD = new double[TP1A_APD_Length];
		TP1A_Recovery_Variable_APD = new double[TP1A_APD_Length];

		for(long i=0;i<TP1A_APD_Length;i++)
		{
			dfile >> s; TP1A_Activation_Variable_APD[i] = atof(s);
			dfile >> s; TP1A_Recovery_Variable_APD[i] = atof(s);
		}
	}

	Min_Custom_Value = 0;
	Max_Custom_Value = 1;

}

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

int TP1A_2D_system_class::save_object(ofstream* dfile)
{
	dfile[0] << " version_5_TP1A "; // in progress of modyfying (sept 2025)

	dfile[0] << Size_X << " ";
	dfile[0] << Size_Y << " ";

	for(long i=0;i<Size_X;i++)
	for(long j=0;j<Size_Y;j++)
	{
		dfile[0] << V1[i][j] << " ";
		dfile[0] << V2[i][j] << " ";
		dfile[0] << W1[i][j] << " ";
		dfile[0] << W2[i][j] << " ";
		dfile[0] << DX[i][j] << " ";
		dfile[0] << DY[i][j] << " ";
		dfile[0] << MI1[i][j] << " ";
		dfile[0] << MI2[i][j] << " ";
	}

	dfile[0] << Boundary_Conditions << " ";

	// parameters
	dfile[0] << k_par << " ";
	dfile[0] << a << " ";
	dfile[0] << eps << " ";
	dfile[0] << mi1 << " ";
	dfile[0] << mi2 << " ";
	dfile[0] << b << " ";

    dfile[0] << dx << " ";
	dfile[0] << dt << " ";

	dfile[0] << Global_Time << " ";

}

//---------------------------------------------------------------------------

int TP1A_2D_system_class::load_object(ifstream* dfile)
{
	char string[2000];
	long S1;
	double tmp=0;

	dfile[0] >> string;

	//--------------------------------------------------------------------
	if( !strcmp(string,"version_5_TP1A") )
	//--------------------------------------------------------------------
	{
	dfile[0] >> Size_X;
	dfile[0] >> Size_Y;

	if( Size_X != TWO_DIM_SYSTEM_X_SIZE ||
		Size_Y != TWO_DIM_SYSTEM_Y_SIZE )
	{
		ShowMessage("Incorrect system dimensions");
		return -1;
	}


	allocate_tables();
	long S;
	double v;

	for(long i=0;i<Size_X;i++)
	for(long j=0;j<Size_Y;j++)
	{
		dfile[0] >> V1[i][j];
		dfile[0] >> V2[i][j];
		dfile[0] >> W1[i][j];
		dfile[0] >> W2[i][j];
		dfile[0] >> DX[i][j];
		dfile[0] >> DY[i][j];
		dfile[0] >> MI1[i][j];
		dfile[0] >> MI2[i][j];
	}

	dfile[0] >> Boundary_Conditions;

	// parameters
	dfile[0] >> k_par;
	dfile[0] >> a;
	dfile[0] >> eps;
	dfile[0] >> mi1;
	dfile[0] >> mi2;
	dfile[0] >> b;

	dfile[0] >> dx;
	dfile[0] >> dt;

	dfile[0] >> Global_Time;

	///////////////

	return 1;

	} // version_5

	ShowMessage("Not TusscherPanfilov system saved in this file.");
	return -1;

/*
	//--------------------------------------------------------------------
	if( !strcmp(string,"version_4") )
	//--------------------------------------------------------------------
	{
	dfile[0] >> Size_X;
	dfile[0] >> Size_Y;

	if( Size_X != TWO_DIM_SYSTEM_X_SIZE ||
		Size_Y != TWO_DIM_SYSTEM_Y_SIZE )
	{
		ShowMessage("Incorrect system dimensions");
		return -1;
	}


	allocate_tables();
	long S;
	double v;

	for(long i=0;i<Size_X;i++)
	for(long j=0;j<Size_Y;j++)
	{
		dfile[0] >> V1[i][j];
		dfile[0] >> V2[i][j];
		dfile[0] >> W1[i][j];
		dfile[0] >> W2[i][j];
		dfile[0] >> DX[i][j];
		dfile[0] >> DY[i][j];
		dfile[0] >> MI1[i][j];
		dfile[0] >> MI2[i][j];

		dfile[0] >> S;
		for(long t=0;t<S;t++)
		{
			dfile[0] >> v;
//			VOLTAGE_HISTORY[i][j].DVector.push_back(v);
		}

		dfile[0] >> S;
		for(long t=0;t<S;t++)
		{
			dfile[0] >> v;
//			PHASE[i][j].DVector.push_back(v);
		}
	}

	VOLTAGE_HISTORY_Time_Axis_ms.clear();
	dfile[0] >> S1;
	VOLTAGE_HISTORY_Time_Axis_ms.assign(S1,tmp);
	for(long i=0;i<VOLTAGE_HISTORY_Time_Axis_ms.size();i++)
	dfile[0] >> VOLTAGE_HISTORY_Time_Axis_ms[i];

    ISIs.clear();
	dfile[0] >> S1;
	ISIs.assign(S1,tmp);
	for(long i=0;i<ISIs.size();i++)
	dfile[0] >>  ISIs[i];

    dfile[0] >> ISIs_Node_Ptr_X;

	dfile[0] >> v;
	dfile[0] >> v;
	dfile[0] >> Boundary_Conditions;

	// parameters
	dfile[0] >> k_par;
	dfile[0] >> a;
	dfile[0] >> eps;
	dfile[0] >> mi1;
	dfile[0] >> mi2;
	dfile[0] >> b;

	dfile[0] >> dx;
	dfile[0] >> dt;

	dfile[0] >> Global_Time;

	///////////////

	return 1;

	} // version_4

	//--------------------------------------------------------------------
	if( !strcmp(string,"version_3") )
	//--------------------------------------------------------------------
	{
	dfile[0] >> Size_X;
	dfile[0] >> Size_Y;

	if( Size_X != TWO_DIM_SYSTEM_X_SIZE ||
		Size_Y != TWO_DIM_SYSTEM_Y_SIZE )
	{
		ShowMessage("Incorrect system dimensions");
		return -1;
	}


	allocate_tables();
	long S;
	double v;

	for(long i=0;i<Size_X;i++)
	for(long j=0;j<Size_Y;j++)
	{
		dfile[0] >> V1[i][j];
		dfile[0] >> V2[i][j];
		dfile[0] >> W1[i][j];
		dfile[0] >> W2[i][j];
		dfile[0] >> DX[i][j];
		dfile[0] >> DY[i][j];
		dfile[0] >> MI1[i][j];
		dfile[0] >> MI2[i][j];

		dfile[0] >> S;
		for(long t=0;t<S;t++)
		{
			dfile[0] >> v;
			VOLTAGE_HISTORY[i][j].DVector.push_back(v);
		}
	}

	VOLTAGE_HISTORY_Time_Axis_ms.clear();
	dfile[0] >> S1;
	VOLTAGE_HISTORY_Time_Axis_ms.assign(S1,tmp);
	for(long i=0;i<VOLTAGE_HISTORY_Time_Axis_ms.size();i++)
	dfile[0] >> VOLTAGE_HISTORY_Time_Axis_ms[i];

    ISIs.clear();
	dfile[0] >> S1;
	ISIs.assign(S1,tmp);
	for(long i=0;i<ISIs.size();i++)
	dfile[0] >>  ISIs[i];

    dfile[0] >> ISIs_Node_Ptr_X;

	dfile[0] >> v;
    dfile[0] >> v;
	dfile[0] >> Boundary_Conditions;

	// parameters
	dfile[0] >> k_par;
	dfile[0] >> a;
	dfile[0] >> eps;
	dfile[0] >> mi1;
	dfile[0] >> mi2;
	dfile[0] >> b;

	dfile[0] >> dx;
	dfile[0] >> dt;

	dfile[0] >> Global_Time;

	///////////////

	return 1;

	} // version_3
*/
}

//---------------------------------------------------------------------------

void TP1A_2D_system_class::set_mi_distribution(double mi1_left,double mi2_left,
							 double mi1_right,double mi2_right,
							 double Ratio)
{
	if( Ratio >= 0 & Ratio <= 1 )
	{

	for( int i=0; i<Ratio*Size_X; i++)
	for( int j=0; j<Size_Y; j++)
	{
		MI1[i][j] = mi1_left;
		MI2[i][j] = mi2_left;
	}

	for( int i=Ratio*Size_X; i<Size_X; i++)
	for( int j=0; j<Size_Y; j++)
	{
		MI1[i][j] = mi1_right;
		MI2[i][j] = mi2_right;
	}
	}
}

//---------------------------------------------------------------------------

int TP1A_2D_system_class::allocate_tables()
{
	vector_of_doubles D;
	D.DVector.clear();

	for( int i=0; i<Size_X; i++)
	for( int j=0; j<Size_Y; j++)
	{
		DX[i][j] = Max_Diff_X;
		DY[i][j] = Max_Diff_Y;
		MI1[i][j] = mi1;
		MI2[i][j] = mi2;
		CUSTOM_VALUE[i][j]=0.5;
	}

	clear_system();

	return 1;
}

//---------------------------------------------------------------------------

void TP1A_2D_system_class::set_mi_breakup_rings(double mi1_min,double mi1_max,
							 double Radius, long Number,bool Middle)
{
	// set all to normal value
	for( int i=0; i<Size_X; i++)
	for( int j=0; j<Size_Y; j++)
	{
		MI1[i][j] = mi1_max;
	}

	//------------------------------
	// discs
	//------------------------------
	for(int i=0;i<Number;i++)
	{

	int x = random( Size_X );
	int y = random( Size_Y );

	if( Middle )
	{
		x = 0.5*Size_X;
		y = 0.5*Size_Y;
	}

	for( int i1=x-Radius; i1<x+Radius; i1++)
	for( int j1=y-Radius; j1<y+Radius; j1++)
	if( sqrt(pow(i1-x,2)+pow(j1-y,2)) < Radius )
	if( i1 >= 0 && i1 < Size_X )
	if( j1 >= 0 && j1 < Size_Y )
	{
		MI1[i1][j1] = mi1_min;
	}

	}

}

//---------------------------------------------------------------------------
void TP1A_2D_system_class::set_mi_breakup_landscape(double R, double p, double I,
		double min, double max, int Target_Variable)
{
	double r;

	if( Target_Variable == 0 )
	{
		for( int i=0; i<Size_X; i++)
		for( int j=0; j<Size_Y; j++)
		{
		DX[i][j] = Max_Diff_X;
		DY[i][j] = Max_Diff_Y;
		}
	}
    else
	for( int i=0; i<Size_X; i++)
	for( int j=0; j<Size_Y; j++)
	{
		if( Target_Variable == 1 ) 	MI1[i][j] = max;
		if( Target_Variable == 2 ) 	MI2[i][j] = max;
	}

	for( int i=0; i<Size_X; i++)
	for( int j=0; j<Size_Y; j++)
	{

	if( random( 100000 ) / 100000.0 < p )
	for( int i1=i;i1<= i+2*R;i1++)
	for( int j1=j;j1<= j+2*R;j1++)
	if( i1 < Size_X && j1 < Size_Y )
	{
		r = sqrt( std::pow(i1-R-i,2) + std::pow(j1-R-j,2) );
		if( r <= R )
		{
			if( Target_Variable == 0 ) 	{ DX[i1][j1] -= I*(R-r)/R; DY[i1][j1] -= I*(R-r)/R; }
			if( Target_Variable == 1 ) 	MI1[i1][j1] -= I*(R-r)/R;
			if( Target_Variable == 2 ) 	MI2[i1][j1] -= I*(R-r)/R;
		}

			if( Target_Variable == 0 ) 	{ if( DX[i1][j1] < min ) DX[i1][j1] = min; if( DY[i1][j1] < min ) DY[i1][j1] = min; }
			if( Target_Variable == 1 ) 	if( MI1[i1][j1] < min ) MI1[i1][j1] = min;
			if( Target_Variable == 2 ) 	if( MI2[i1][j1] < min ) MI2[i1][j1] = min;
	}

	}
}

//---------------------------------------------------------------------------
void TP1A_2D_system_class::clear_system()
{
	// Clear grid
	for( int i=0; i<Size_X; i++)
	for( int j=0; j<Size_Y; j++)
	{
		V1[i][j] = 0;
		V2[i][j] = 0;
		W1[i][j] = 0;
		W2[i][j] = 0;
		CUSTOM_VALUE[i][j] = 0;
	}
}

//---------------------------------------------------------------------------

void TP1A_2D_system_class::compute_N_steps(int N)
{
    for(int n=0;n<N;n++)
    {
        calculate_V1_from_V2_fhn();
        calculate_V2_from_V1_fhn();
		Global_Time += dt;

		add_assymetric_modulation();
		add_current_modulation_1();

    }
}

//---------------------------------------------------------------------------

void TP1A_2D_system_class::calculate_V2_from_V1_fhn()
{
//fff21
      int i,j,k,l;
      double e,r,k1,k2,w = 0.5,xp,yp;
      double diff_term,s2=dx*dx;

      // matrix V without boundaries
      for( i = 1; i < Size_X - 1; i++ )
	  for( j = 1; j < Size_Y - 1; j++ )
      {
        diff_term = ( DX[i][j]*(V1[i-1][j] + V1[i+1][j] - 2*V1[i][j]) +
                      DY[i][j]*(V1[i][j+1] + V1[i][j-1] - 2*V1[i][j]) ) / s2;

        // Forward Euler
        V2[i][j] = V1[i][j] + dt*
            ( -k_par*V1[i][j]*(V1[i][j]-a)*(V1[i][j]-1)-V1[i][j]*W1[i][j]+ diff_term);

        W2[i][j] = W1[i][j] + dt*
        (eps+(MI1[i][j]*W1[i][j])/(MI2[i][j]+V1[i][j]))*
             (-W1[i][j]-k_par*V1[i][j]*(V1[i][j]-b-1));
      }

    //---------------------------------------------------------------------
    if( Boundary_Conditions == 0 ) // zero flux
    //---------------------------------------------------------------------
    {
      // "X" side
      for( i = 1; i < Size_X - 1; i++ )
      {
			V2[i][0] = V2[i][1];
            V2[i][Size_Y-1] = V2[i][Size_Y-2];

            W2[i][0] = W2[i][1];
            W2[i][Size_Y-1] = W2[i][Size_Y-2];
      }

      // "Y" side
      for( j = 1; j < Size_Y - 1; j++ )
      {
            V2[0][j] = V2[1][j];
            V2[Size_X-1][j] = V2[Size_Y-2][j];

            W2[0][j] = W2[j][1];
            W2[Size_X-1][j] = W2[Size_Y-2][j];
      }
    }

    //---------------------------------------------------------------------
	if( Boundary_Conditions == 1 ) // periodic conditions
    //---------------------------------------------------------------------
    {
      // "X" 0 side
      i = 0;
      for( j = 1; j < Size_Y - 1; j++ )
      {
        diff_term = ( DX[i][j]*(V1[Size_X-1][j] + V1[1][j] -   2*V1[i][j]) +
                      DY[i][j]*(V1[i][j+1]      + V1[i][j-1] - 2*V1[i][j]) )/s2;

        // Forward Euler
        V2[i][j] = V1[i][j] + dt*
            ( -k_par*V1[i][j]*(V1[i][j]-a)*(V1[i][j]-1)-V1[i][j]*W1[i][j]+ diff_term);

        W2[i][j] = W1[i][j] + dt*
		(eps+(MI1[i][j]*W1[i][j])/(MI2[i][j]+V1[i][j]))*
             (-W1[i][j]-k_par*V1[i][j]*(V1[i][j]-b-1));
      }

      // "X" Size_X-1 side
      i = Size_X-1;
      for( j = 1; j < Size_Y - 1; j++ )
      {
        diff_term = ( DX[i][j]*(V1[Size_X-2][j] + V1[0][j] -  2*V1[i][j]) +
                      DY[i][j]*(V1[i][j+1]      + V1[i][j-1]- 2*V1[i][j]) )/s2;

        // Forward Euler
        V2[i][j] = V1[i][j] + dt*
            ( -k_par*V1[i][j]*(V1[i][j]-a)*(V1[i][j]-1)-V1[i][j]*W1[i][j]+ diff_term);

        W2[i][j] = W1[i][j] + dt*
        (eps+(MI1[i][j]*W1[i][j])/(MI2[i][j]+V1[i][j]))*
             (-W1[i][j]-k_par*V1[i][j]*(V1[i][j]-b-1));
	  }

      // "Y" 0 side
      j = 0;
      for( i = 1; i < Size_X - 1; i++ )
      {
        diff_term = ( DX[i][j]*(V1[i-1][j]       + V1[i+1][j] -  2*V1[i][j]) +
                      DY[i][j]*(V1[i][Size_Y-1]  + V1[i][1]   - 2*V1[i][j]) )/s2;

        // Forward Euler
        V2[i][j] = V1[i][j] + dt*
            ( -k_par*V1[i][j]*(V1[i][j]-a)*(V1[i][j]-1)-V1[i][j]*W1[i][j]+ diff_term);

        W2[i][j] = W1[i][j] + dt*
		(eps+(MI1[i][j]*W1[i][j])/(MI2[i][j]+V1[i][j]))*
			 (-W1[i][j]-k_par*V1[i][j]*(V1[i][j]-b-1));
      }

      // "Y" Size_Y-1 side
      j = Size_Y-1;
      for( i = 1; i < Size_X - 1; i++ )
      {
        diff_term = ( DX[i][j]*(V1[i-1][j]       + V1[i+1][j] -  2*V1[i][j]) +
                      DY[i][j]*(V1[i][Size_Y-2]  + V1[i][0]   - 2*V1[i][j]) )/s2;

        // Forward Euler
        V2[i][j] = V1[i][j] + dt*
            ( -k_par*V1[i][j]*(V1[i][j]-a)*(V1[i][j]-1)-V1[i][j]*W1[i][j]+ diff_term);

        W2[i][j] = W1[i][j] + dt*
        (eps+(MI1[i][j]*W1[i][j])/(MI2[i][j]+V1[i][j]))*
             (-W1[i][j]-k_par*V1[i][j]*(V1[i][j]-b-1));
      }

	}

	// corners
	V2[0][0]=V2[1][1];
	V2[Size_X-1][0]=V2[Size_X-2][1];
	V2[0][Size_Y-1]=V2[1][Size_Y-2];
	V2[Size_X-1][Size_X-1]=V2[Size_X-2][Size_X-2];
}

//------------------------------------------------------------------------------

void TP1A_2D_system_class::calculate_V1_from_V2_fhn()
{
//fff12
      int i,j,k,l;
      double e,r,k1,k2,w = 0.5,xp,yp;
      double diff_term,s2=dx*dx;

	  // matrix V without boundaries
      for( i = 1; i < Size_X - 1; i++ )
      for( j = 1; j < Size_Y - 1; j++ )
      {

        diff_term = ( DX[i][j]*(V2[i-1][j] + V2[i+1][j] - 2*V2[i][j]) +
                      DY[i][j]*(V2[i][j+1] + V2[i][j-1] - 2*V2[i][j]) ) / s2;

		// Forward Euler
		V1[i][j] = V2[i][j] + dt*
			( -k_par*V2[i][j]*(V2[i][j]-a)*(V2[i][j]-1)-V2[i][j]*W2[i][j]+ diff_term);

		W1[i][j] = W2[i][j] + dt*
		(eps+(MI1[i][j]*W2[i][j])/(MI2[i][j]+V2[i][j]))*
			 (-W2[i][j]-k_par*V2[i][j]*(V2[i][j]-b-1));
	  }

    //---------------------------------------------------------------------
    if( Boundary_Conditions == 0 ) // zero flux
    //---------------------------------------------------------------------
    {
      // "X" side
      for( i = 1; i < Size_X - 1; i++ )
      {
            V1[i][0] = V1[i][1];
            V1[i][Size_Y-1] = V1[i][Size_Y-2];

            W1[i][0] = W1[i][1];
            W1[i][Size_Y-1] = W1[i][Size_Y-2];
      }

      // "Y" side
      for( j = 1; j < Size_Y - 1; j++ )
      {
            V1[0][j] = V1[1][j];
            V1[Size_X-1][j] = V1[Size_Y-2][j];

            W1[0][j] = W1[j][1];
            W1[Size_X-1][j] = W1[Size_Y-2][j];
      }
    }

    //---------------------------------------------------------------------
    if( Boundary_Conditions == 1 ) // periodic conditions
    //---------------------------------------------------------------------
    {
      // "X" 0 side
      i = 0;
	  for( j = 1; j < Size_Y - 1; j++ )
      {

        diff_term = ( DX[i][j]*(V2[Size_X-1][j] + V2[1][j] -   2*V2[i][j]) +
					  DY[i][j]*(V2[i][j+1]      + V2[i][j-1] - 2*V2[i][j]) )/s2;

        // Forward Euler
        V1[i][j] = V2[i][j] + dt*
            ( -k_par*V2[i][j]*(V2[i][j]-a)*(V2[i][j]-1)-V2[i][j]*W2[i][j]+ diff_term);

        W1[i][j] = W2[i][j] + dt*
        (eps+(MI1[i][j]*W2[i][j])/(MI2[i][j]+V2[i][j]))*
             (-W2[i][j]-k_par*V2[i][j]*(V2[i][j]-b-1));
      }

      // "X" Size_X-1 side
      i = Size_X-1;
	  for( j = 1; j < Size_Y - 1; j++ )
      {

        diff_term = ( DX[i][j]*(V2[Size_X-2][j] + V2[0][j] -  2*V2[i][j]) +
                      DY[i][j]*(V2[i][j+1]      + V2[i][j-1]- 2*V2[i][j]) )/s2;

        // Forward Euler
        V1[i][j] = V2[i][j] + dt*
            ( -k_par*V2[i][j]*(V2[i][j]-a)*(V2[i][j]-1)-V2[i][j]*W2[i][j]+ diff_term);

        W1[i][j] = W2[i][j] + dt*
        (eps+(MI1[i][j]*W2[i][j])/(MI2[i][j]+V2[i][j]))*
             (-W2[i][j]-k_par*V2[i][j]*(V2[i][j]-b-1));
	  }

      // "Y" 0 side
      j = 0;
      for( i = 1; i < Size_X - 1; i++ )
      {
        diff_term = ( DX[i][j]*(V2[i-1][j]       + V2[i+1][j] -  2*V2[i][j]) +
                      DY[i][j]*(V2[i][Size_Y-1]  + V2[i][1]   - 2*V2[i][j]) )/s2;

        // Forward Euler
        V1[i][j] = V2[i][j] + dt*
            ( -k_par*V2[i][j]*(V2[i][j]-a)*(V2[i][j]-1)-V2[i][j]*W2[i][j]+ diff_term);

        W1[i][j] = W2[i][j] + dt*
        (eps+(MI1[i][j]*W2[i][j])/(MI2[i][j]+V2[i][j]))*
             (-W2[i][j]-k_par*V2[i][j]*(V2[i][j]-b-1));
      }

      // "Y" Size_Y-1 side
      j = Size_Y-1;
      for( i = 1; i < Size_X - 1; i++ )
      {
        diff_term = ( DX[i][j]*(V2[i-1][j]       + V2[i+1][j] -  2*V2[i][j]) +
                      DY[i][j]*(V2[i][Size_Y-2]  + V2[i][0]   - 2*V2[i][j]) )/s2;

        // Forward Euler
		V1[i][j] = V2[i][j] + dt*
            ( -k_par*V2[i][j]*(V2[i][j]-a)*(V2[i][j]-1)-V2[i][j]*W2[i][j]+ diff_term);

        W1[i][j] = W2[i][j] + dt*
		(eps+(MI1[i][j]*W2[i][j])/(MI2[i][j]+V2[i][j]))*
             (-W2[i][j]-k_par*V2[i][j]*(V2[i][j]-b-1));
      }

	}

	// corners
	V1[0][0]=V1[1][1];
	V1[Size_X-1][0]=V1[Size_X-2][1];
	V1[0][Size_Y-1]=V1[1][Size_Y-2];
	V1[Size_X-1][Size_X-1]=V1[Size_X-2][Size_X-2];

}

//------------------------------------------------------------------------------

void TP1A_2D_system_class::create_spiral(int Slice_Plane) // 0-xy,
{
    double wn,r,fi,phase,x,y,d;
    double cx,cy;
    long n;

    // winding number
    wn = 245.0;

    clear_system();

    cx = Size_X/2;
    cy = Size_Y/2;

	if( Slice_Plane == 0 ) // spiral wave in XY plane
    for( int i=0;i<Size_X; i++ )
    for( int j=0;j<Size_Y; j++ )
    {
        // distance from center of the spiral in dx units
        r = std::sqrt( std::pow(i-cx,2) + std::pow(j-cy,2));

        x = i-cx;
        y = j-cy;

        if( i-cx != 0.0 )
        {
            d = atan(fabs(y/x));

            // 1st quarter
            if( x >= 0 && y >= 0 )
                fi = d;

			// 2nd quarter
            if( x <= 0 && y >= 0 )
                fi = M_PI - d;

            // 3rd quarter
            if( x <= 0 && y <= 0 )
                fi = M_PI + d;

            // 4th quarter
            if( x >= 0 && y <= 0 )
                fi = 2.0*M_PI - d;
        }
		else
		{
            if( j-0.5*Size_Y > 0.0 )
                 fi = M_PI_2;
            else
                 fi = 3.0*M_PI_2;
        }

        fi += 0.55;

        // find the greatest n such that r > k*fi + 2pi*k*n
        if(wn*fi!=0)
			n = floor( (r-wn*fi)/(2.0*M_PI*wn) );
        else
            n = 0;

        phase = fabs(r-wn*fi-2.0*wn*M_PI*n)/(2.0*wn*M_PI);
        int m = (int)((1.0-phase)*(TP1A_APD_Length-2));

        V1[i][j] = TP1A_Activation_Variable_APD[m];
        V2[i][j] = TP1A_Activation_Variable_APD[m];
        W1[i][j] = 1*TP1A_Recovery_Variable_APD[m];
        W2[i][j] = 1*TP1A_Recovery_Variable_APD[m];
    }
}


//---------------------------------------------------------------------------

void TP1A_2D_system_class::stimulate_node(int X,int Y)
{
	if( X >= 0 && X < TWO_DIM_SYSTEM_X_SIZE )
	if( Y >= 0 && Y < TWO_DIM_SYSTEM_Y_SIZE )
	{
		V1[X][Y]=1;
		V2[X][Y]=1;
	}
}

//---------------------------------------------------------------------------

void TP1A_2D_system_class::add_assymetric_modulation()
{
/*
	if( Add_Assymetric_Modulation )
	{
	double Modulation;

	double t1 = floor(Global_Time/Asm_Length)*Asm_Length;
	double t2 = (floor(Global_Time/Asm_Length)+1)*Asm_Length;

	if( Global_Time < t1 + Asm_Ratio*Asm_Length)
	Modulation = Asm_Amplitude*(Global_Time-t1)/(Asm_Ratio*Asm_Length);
	else
	Modulation = Asm_Amplitude*(t2-Global_Time)/((1-Asm_Ratio)*Asm_Length);

	long XL = 0.5*Size_X - Central_Region_Relative_Size*Size_X/2;
	long XR = 0.5*Size_X + Central_Region_Relative_Size*Size_X/2;

	long YL = 0.5*Size_Y - Central_Region_Relative_Size*Size_Y/2;
	long YR = 0.5*Size_Y + Central_Region_Relative_Size*Size_Y/2;

	for(long i=XL;i<XR;i++)
	for(long j=YL;j<YR;j++)
	{
		if(V1[i][j] + Modulation < Max_Voltage )
		V1[i][j] += Modulation;
		if(V2[i][j] + Modulation < Max_Voltage )
		V2[i][j] += Modulation;
	}

	}
*/
}

//---------------------------------------------------------------------------

void TP1A_2D_system_class::add_current_modulation_1()
{
/*
	if( Add_Current_Modulation_1 )
	{
	double Modulation = CM1_Amplitude*sin(2*M_PI/CM1_Length*Global_Time);
	if( Modulation > 0 )
	Modulation = 0;

	long XL = 0.5*Size_X - Central_Region_Relative_Size*Size_X/2;
	long XR = 0.5*Size_X + Central_Region_Relative_Size*Size_X/2;

	long YL = 0.5*Size_Y - Central_Region_Relative_Size*Size_Y/2;
	long YR = 0.5*Size_Y + Central_Region_Relative_Size*Size_Y/2;

	for(long i=XL;i<XR;i++)
	for(long j=YL;j<YR;j++)
	{
		if(V1[i][j] + Modulation < Max_Voltage )
		V1[i][j] += Modulation;
		if(V2[i][j] + Modulation < Max_Voltage )
		V2[i][j] += Modulation;
	}

	}
*/
}

//---------------------------------------------------------------------------

bool TP1A_2D_system_class::activity_present_check()
{
	bool Activity_Present = false;
	double Threshold = 0.5;

	for( int i=1; i<Size_X-1; i++)
	for( int j=1; j<Size_Y-1; j++)
	if( V1[i][j] > Threshold )
		Activity_Present = true;

	return Activity_Present;
}

//------------------------------------------------------------------------------

/*
void __fastcall TNL_Analysis_Form::Sliding_Window_Corr_L_ButtonClick(TObject *Sender)
{
	Ask_For_Single_Item_Form1->Caption = "Window length [ms]: ";
	Ask_For_Single_Item_Form1->Edit_Box->Text = "3000";
	if( Ask_For_Single_Item_Form1->ShowModal() == mrOk )
	{

	int Corr_L_W_Size_ms = Ask_For_Single_Item_Form1->Edit_Box->Text.ToInt();

	Ask_For_Single_Item_Form1->Caption = "Sliding step [ms]: ";
	Ask_For_Single_Item_Form1->Edit_Box->Text = "100";
	if( Ask_For_Single_Item_Form1->ShowModal() == mrOk )
	{
		int Corr_L_step_ms = Ask_For_Single_Item_Form1->Edit_Box->Text.ToInt();

		sliding_window_correlation_length_analysis(Corr_L_W_Size_ms, Corr_L_step_ms);
	}
	}
}
//---------------------------------------------------------------------------
*/

void TP1A_2D_system_class::set_timestep(double Timestep)
{
	dt = Timestep;
}

//-------------------------------------------------------------------

double TP1A_2D_system_class::get_MI_parameter(int Which,int X, int Y)
{
	if( Which == 1 )
	return MI1[X][Y];

	if( Which == 2 )
	return MI2[X][Y];

	return 0;
}

//---------------------------------------------------------------------------

